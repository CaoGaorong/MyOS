

###  1. 本操作系统简介

本操作系统是一个32位的分时操作系统，基于x86系列CPU（80386以上）。

上述文件夹介绍：

- src：源代码。里面有所有的C源码和汇编源码，还有我制作好的硬盘镜像文件（可以直接使用虚拟机启动），以及bochs虚拟机的配置文件```bochsrc.disk```
- 代码讲解：文件夹里面对于该系统的重点代码，进行了讲解，并且配合了重要的理论知识。推荐查看。
- 文档用到的图片：该文件夹是是在编写文档时，配上的图片，是我使用```drawio```软件绘制而成。
- 理论总结：该文件夹下的文件，是纯粹的理论知识，讲解的比较详细。



#### 1.1 各个模块简介

该系统从BIOS启动，到加载Loader，然后加载操作系统内核。该系统不是实现了一个完整的操作系统，而是实现了一个精简的内核，简单介绍一下模块：

- 输入输出
  - 先说最基本的输入输出，一个系统必须要和用户交互，所以输入输出必须要有
  - 本系统可以从键盘获取用户输入，也可以把ascii码输出到屏幕中
  - 输入是通过直接读写键盘控制器端口来获取输入的
  - 输出是直接操作显存0xb8000然后在屏幕上输出文字的

- 中断管理
  - 构建中断描述符，注册中断处理程序。中断的触发有两种：硬中断和软中断。
  - 对于硬件中断，是操作比较古老的中断控制器8259A，来控制硬件的中断，包括时钟中断、键盘中断。
    - 通过映射8259A的硬件端口到中断向量号，然后8259A不同的端口收到不同的中断信号，会产生不同的中断向量号，根据中断向量号会对应不同的中断描述符，会触发不同的中断。
  - 对于软中断，即使用```int```指令发起的中断，本系统主要是对软中断进行封装成系统调用。
- 内存管理
  - 对于内存管理，本系统支持分页、虚拟内存
  - 虚拟地址和物理地址通过页表来建立映射，页表是使用的二级页表。
  - 本系统使用位图这种数据结构来管理内存（虚拟内存和物理内存）
  - 操作系统最小分配单位是1个物理页（4KB），但是对于用户程序，最小申请单位是16字节（可以修改的）（用户程序使用malloc分配不足16字节按照16字节算）。
    - 为什么操作系统分配的单位和用户可以申请不同？操作系统按照页来分配，1页分成很多小块，小块最小规格是16B，然后把小块分配给应用程序（多余的会串起来放在进程/线程的PCB中）。
  - 本系统支持内存分配和释放，即实现了系统调用```malloc```和```free```
  - 对内存的分配需要进行加锁

- 进程管理
  - 本系统实现了内核线程和用户进程
  - 内核线程，有独立的PCB，但是共用操作系统的页表
  - 用户进程由自己的PCB，有独立的页表。
    - 还未实现用户线程
    - 所以用户进程只能有一条执行流
  - 线程是由操作系统统一调度
    - 调度算法使用的是RR算法
  - 实现了idle线程，在没有线程可以调度时，会执行idle线程，即该线程代码就是hlt指令
  - 用户进程支持fork系统调用，可以创建子进程。用户进程的祖先进城是```init```进程
  - 进程也实现了wait和exit系统调用，用于进程退出回收空间
  - 但是，可惜的是本系统没有实现文件系统，所以无法将程序从硬盘中加载到内存中去执行
- 系统调用的封装
  - 系统调用是对软中断进行封装，并且模仿Linux系统，使用```int 0x80```来发起系统调用，即0x80号中断描述符用于系统调用
  - 此外，本系统实现的系统调用有：```getpid```获取pid、```write```向屏幕输出内容、```read```读取键盘输入、```malloc```分配内存空间、```ps```显示当前线程状态、```wait```父进程回收子进程、```exit```进程退出、```execv```执行进程。

- shell
  - 本系统使用CLI，只能使用shell与系统交互，shell也是由init进程fork出来的用户进程。
  - 由于没有实现文件系统，，所以目前无法使用cd、ls等常见操作文件系统的命令，没有文件系统也就无法从硬盘中加载程序，所以shell可以干的事情比较少。
  - 目前shell只能使用ps、help命令，其中ps可以查看当前线程的状态。help可以查看提供的命令
  - 由于本系统不能从硬盘加载程序，所以我内置了两个用户进程，分别是```hello```和```echo```。
    - ```hello```的功能就是输出```Hello, World```。
    - ```echo```可以将echo后面的参数进行输出
    - 注意这是进程，不是命令
  - shell添加了两个快捷键```ctrl+l```清除屏幕和```ctrl+u```清除当行输入

经过上述的操作，构建好的操作系统固定的内存空间使用如图所示：

（图片显示不全？点击链接查看：<a href="https://gitee.com/imcgr/image_blog/raw/master/20210625205523.png">操作系统内存构建图</a> ）

![操作系统内存图](https://gitee.com/imcgr/image_blog/raw/master/20210625205523.png)

- 以上有颜色的部分即[0x0, 0x20 0000]内存都是不可分配的，都是操作系统固定使用的
- 其余的白色部分内存空间是可以动态分配的



以上就是本系统主要实现了的核心功能。



#### 1.2 功能展示

操作系统显示效果如下（使用bochs虚拟机）：

系统界面：

![系统界面](https://gitee.com/imcgr/image_blog/raw/master/20210625201339.png)



shell可以进行的操作：

![help命令](https://gitee.com/imcgr/image_blog/raw/master/20210625201435.png)

ps命令演示：

![](https://gitee.com/imcgr/image_blog/raw/master/20210625201521.png)

- 上述有3个进程在执行，分别是：
  - init进程，所有用户进程的祖先进城
  - idle进程，当没有线程可以执行就会执行该进程
  - init_fork进程，就是的当前shell，由于该进程是由init进程fork出来的，所以叫init_fork



测试内置的进程```hello```和```echo```：

测试```hello```进程：

![](https://gitee.com/imcgr/image_blog/raw/master/20210625201909.png)

- 输入```hello```会创建```hello```进程
- 注意，这是执行了1个进程，不是shell的命令
- 上述显示```The process with pid 4 exited with status 0```是```init```进程输出的，因为这个```hello```进程是由```init```进程创建的，而```init```进程会使用```wait```来回收```hello```进程的空间



测试```echo```进程：

![](https://gitee.com/imcgr/image_blog/raw/master/20210625202203.png)

- ```echo```进程和Linux上的```echo```功能一样，就是输出



以上就是该操作系统基本的介绍和使用。

### 2. 模块介绍

下面对各个模块，详细介绍一下。

还是不介绍了吧，可以看看我上面的“代码讲解”文件夹的内容，里面结合代码进行了详细的讲解。



### 3. 不足之处

本系统只是一个非常精简的操作系统内核，并且还没有文件系统非常不完善。

所以还有很多地方又该改进，最基本的就是实现文件系统，还有我想实现GUI，还有本系统是32位的，想能不能弄一个64位的，还有一些硬件操作太老了，比如PIC可编程中断控制器8259A太老的，有比如对硬盘的操作，使用的方式是程序查询和程序中断，没有使用DMA，太低效了，还有如果可以，最好实现TCP/IP协议栈，那么就可以网络通信的。如果再移植编译器就更厉害了哈哈哈。

这个操作系统的学习只是对操作系统刚刚入门，后面我会接着学习。









本系统参考：《操作系统真象还原》



