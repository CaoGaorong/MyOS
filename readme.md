- [1. 本操作系统简介](#1-本操作系统简介)
  - [1.1 各个模块简介](#11-各个模块简介)
  - [1.2 开发环境搭建](#12-开发环境搭建)
    - [1.2.1 安装工具](#121-安装工具)
    - [1.2.2 制作空的硬盘镜像文件](#122-制作空的硬盘镜像文件)
    - [1.2.3 编译链接写入硬盘](#123-编译链接写入硬盘)
    - [1.2.4 启动虚拟机](#124-启动虚拟机)
  - [1.3 系统效果展示](#13-系统效果展示)
- [2. 模块介绍](#2-模块介绍)
- [3. 感想与总结](#3-感想与总结)
- [4. 未来和展望](#4-未来和展望)

##  1. 本操作系统简介

本操作系统是一个32位的分时操作系统，基于x86系列CPU（80386以上）。

上述文件夹介绍：

- src：源代码。里面有所有的C源码和汇编源码，还有我制作好的硬盘镜像文件（可以直接使用虚拟机启动），以及bochs虚拟机的配置文件```bochsrc.disk```
- 代码讲解：文件夹里面对于该系统的重点代码，进行了讲解，并且配合了重要的理论知识。推荐查看。
- 文档用到的图片：该文件夹是是在编写文档时，配上的图片，是我使用```drawio```软件绘制而成。
- 理论总结：该文件夹下的文件，是纯粹的理论知识，讲解的比较详细。

### 1.1 各个模块简介

该系统从BIOS启动，到加载Loader，然后加载操作系统内核。该系统不是实现了一个完整的操作系统，而是实现了一个精简的内核，简单介绍一下模块：

- 输入输出
  - 先说最基本的输入输出，一个系统必须要和用户交互，所以输入输出必须要有
  - 本系统可以从键盘获取用户输入，也可以把ascii码输出到屏幕中
  - 输入是通过直接读写键盘控制器端口来获取输入的
  - 输出是直接操作显存0xb8000然后在屏幕上输出文字的

- 中断管理
  - 构建中断描述符，注册中断处理程序。中断的触发有两种：硬中断和软中断。
  - 对于硬件中断，是操作比较古老的中断控制器8259A，来控制硬件的中断，包括时钟中断、键盘中断。
    - 通过映射8259A的硬件端口到中断向量号，然后8259A不同的端口收到不同的中断信号，会产生不同的中断向量号，根据中断向量号会对应不同的中断描述符，会触发不同的中断。
  - 对于软中断，即使用```int```指令发起的中断，本系统主要是对软中断进行封装成系统调用。
- 内存管理
  - 对于内存管理，本系统支持分页、虚拟内存
  - 虚拟地址和物理地址通过页表来建立映射，页表是使用的二级页表。
  - 本系统使用位图这种数据结构来管理内存（虚拟内存和物理内存）
  - 操作系统最小分配单位是1个物理页（4KB），但是对于用户程序，最小申请单位是16字节（可以修改的）（用户程序使用malloc分配不足16字节按照16字节算）。
    - 为什么操作系统分配的单位和用户可以申请不同？操作系统按照页来分配，1页分成很多小块，小块最小规格是16B，然后把小块分配给应用程序（多余的会串起来放在进程/线程的PCB中）。
  - 本系统支持内存分配和释放，即实现了系统调用```malloc```和```free```
  - 对内存的分配需要进行加锁

- 进程管理
  - 本系统实现了内核线程和用户进程
  - 内核线程，有独立的PCB，但是共用操作系统的页表
  - 用户进程由自己的PCB，有独立的页表。
    - 还未实现用户线程
    - 所以用户进程只能有一条执行流
  - 线程是由操作系统统一调度
    - 调度算法使用的是RR算法
  - 实现了idle线程，在没有线程可以调度时，会执行idle线程，即该线程代码就是hlt指令
  - 用户进程支持fork系统调用，可以创建子进程。用户进程的祖先进城是```init```进程
  - 进程也实现了wait和exit系统调用，用于进程退出回收空间
  - 但是，可惜的是本系统没有实现文件系统，所以无法将程序从硬盘中加载到内存中去执行
- 系统调用的封装
  - 系统调用是对软中断进行封装，并且模仿Linux系统，使用```int 0x80```来发起系统调用，即0x80号中断描述符用于系统调用
  - 此外，本系统实现的系统调用有：```getpid```获取pid、```write```向屏幕输出内容、```read```读取键盘输入、```malloc```分配内存空间、```ps```显示当前线程状态、```wait```父进程回收子进程、```exit```进程退出、```execv```执行进程。

- shell
  - 本系统使用CLI，只能使用shell与系统交互，shell也是由init进程fork出来的用户进程。
  - 由于没有实现文件系统，，所以目前无法使用cd、ls等常见操作文件系统的命令，没有文件系统也就无法从硬盘中加载程序，所以shell可以干的事情比较少。
  - 目前shell只能使用ps、help命令，其中ps可以查看当前线程的状态。help可以查看提供的命令
  - 由于本系统不能从硬盘加载程序，所以我内置了两个用户进程，分别是```hello```和```echo```。
    - ```hello```的功能就是输出```Hello, World```。
    - ```echo```可以将echo后面的参数进行输出
    - 注意这是进程，不是命令
  - shell添加了两个快捷键```ctrl+l```清除屏幕和```ctrl+u```清除当行输入

经过上述的操作，构建好的操作系统固定的内存空间使用如图所示：

（图片显示不全？点击链接查看：<a href="https://gitee.com/imcgr/image_blog/raw/master/20210625205523.png">操作系统内存构建图</a> ）

![操作系统内存图](https://gitee.com/imcgr/image_blog/raw/master/20210625205523.png)

- 以上有颜色的部分即[0x0, 0x20 0000]内存都是不可分配的，都是操作系统固定使用的
- 其余的白色部分内存空间是可以动态分配的



以上就是本系统主要实现了的核心功能。

### 1.2 开发环境搭建

本系统使用nasm汇编和C语言编写的，使用到了make作为“自动编译”的工具来执行makefile脚本。另外使用了bochs虚拟机来制作系统的启动硬盘镜像和运行操作系统。

#### 1.2.1 安装工具

下面介绍下在Linux（以Ubuntu为例）下配置这些环境的方式：

1. 安装nasm
   - 安装nasm直接输入命令```sudo apt install nasm```即可
2. 安装gcc
   - gcc在Linux中都是自带的
3. 安装make
   - 安装make只需要输入命令```sudo apt install make```即可
4. 安装bochs
   - bochs是一个虚拟机，安装的话可以去官网下载:https://bochs.sourceforge.io/



#### 1.2.2 制作空的硬盘镜像文件

上述安装完成后，需要制作一个硬盘镜像，也就是我src文件夹里面的hd60M.img，**如果使用我制作好的```hd60M.img```可以不用制作**，如果要自己重新制作硬盘镜像文件的话，可以使用bochs提供的工具，只需要输入命令：

```c
bximage -mode=create -hd=60 -q hd60M.img
```

上述命令可以制作一个名称为```hd60M.img```的硬盘镜像文件出来（**如果用我已经制作好的可以不用自己制作了**）。



还需要把这个硬盘镜像文件作为bochs的启动盘，所以需要一个bochs的配置文件：```bochsrc.disk```文件。

在```bochsrc.disk```文件后面追加一句，表示把```hd60M.img```作为bochs的启动盘：

```
ata0-master: type=disk, path="hd60M.img", mode=flat, cylinders=121, heads=16, spt=63
```



#### 1.2.3 编译链接写入硬盘

下面就可以进行编译，把mbr、Loader和系统内核kernel写入到硬盘镜像文件```hd60M.img```中去，使用了make工具后，只需要在终端中输入：

```
make all
```

上面命令就会执行makefile文件中的命令，就会编译所有文件，链接成二进制文件，然后把二进制文件写入到硬盘镜像```hd60M.img```中去。



#### 1.2.4 启动虚拟机

上面制作好启动盘后，可以使用bochs虚拟机启动了，输入如下命令：

```
bochs -f bochsrc.disk
```

就会根据```bochsrc.disk```配置文件，来启动bochs虚拟机，然后根据```bochsrc.disk```中配置了```hd60M.img```作为启动盘，所以bochs启动进入bios后，就会加载```hd60M.img```作为启动盘，就会开始启动了。



### 1.3 系统效果展示

操作系统显示效果如下（使用bochs虚拟机）：

系统界面：

![系统界面](https://gitee.com/imcgr/image_blog/raw/master/20210625201339.png)



shell可以进行的操作：

![help命令](https://gitee.com/imcgr/image_blog/raw/master/20210625201435.png)

ps命令演示：

![](https://gitee.com/imcgr/image_blog/raw/master/20210625201521.png)

- 上述有3个进程在执行，分别是：
  - init进程，所有用户进程的祖先进程
  - idle进程，当没有线程可以执行就会执行该进程
  - init_fork进程，就是的当前shell，由于该进程是由init进程fork出来的，所以叫init_fork



测试内置的进程```hello```和```echo```：

测试```hello```进程：

![](https://gitee.com/imcgr/image_blog/raw/master/20210625201909.png)

- 输入```hello```会创建```hello```进程
- **注意，这是执行了1个进程，不是shell的命令**
- 上述显示```The process with pid 4 exited with status 0```是```init```进程输出的，因为这个```hello```进程是由```init```进程创建的，而```init```进程会使用```wait```来回收```hello```进程的空间



测试```echo```进程：

![](https://gitee.com/imcgr/image_blog/raw/master/20210625202203.png)

- ```echo```进程和Linux上的```echo```功能一样，就是输出



以上就是该操作系统基本的介绍和使用。

## 2. 模块介绍

下面对各个模块，详细介绍一下。

还是不介绍了吧，可以看看我上面的“代码讲解”文件夹的内容，里面结合代码进行了详细的讲解。



## 3. 感想与总结

制作这个操作系统，虽然不是我100%原创（但是有我自己的东西，我做了部分改动），花费了我好几个月的时间，学习到很多知识，这是认为我做得最值得的一个项目。

我早就有实现操作系统的想法，但一直不敢去实现。认为操作系统低层这些东西太高深，只有大佬才能看的懂。另一方面，操作系统底层在我们应用层编程根本接触不到，学习这个性价比不高。所以我一直犹豫不决，担心我自己实现不了，担心我浪费了太多时间。

后来受到一位我非常佩服的公众号号主的影响（《码农翻身》），他发了一篇文章《计算机系的同学应该有更高的雄心壮志》。那篇文章提到说，现在的互联网太浮躁了，都只去学习各种框架，增删改查，而底层的基础知识很少有人学习，而在大学期间有大把集中的时间，不应该只去学习增删改查、各种框架，而更应该去学习底层的基础知识，比如自制操作系统、自制数据库、自制编程语言。

我原本就对底层知识比较感兴趣，然后看到这篇文章，更坚定了我去深入学习操作系统的决心。后来买了很多书，决定跟着书上完整地实现这个操作系统。那本书很厚，内容很多，而且理论知识也比较枯燥，一开始我也不敢相信自己可以坚持看完，中途我也一度想要放弃，最终还是坚持了下来。

而把整个项目做下来，我感觉非常值！



操作系统作为所有应用层软件的基础平台，任何应用软件都依赖于操作系统，对于应用软件来说，很多操作都是抽象的、透明的（比如读写外设、申请内存等需要系统调用的操作），平时在学习这些应用层的开发时，我也经常会去想，这个操作低层到底是如何实现的，操作系统和应用程序和硬件又是什么样的关系，这些问题经常会让我困惑，并且这些疑问也很难解开，即使学习了操作系统理论，但是还是非常抽象。

直到我亲自使用代码来实现这个操作系统内核，我才真正弄清楚操作系统是在干什么，弄清楚操作系统和应用程序以及硬件的关系，知道了操作系统是如何处理中断的，又是如何管理资源的（比如CPU、内存），也知道了操作系统和硬件的关系（操作系统作为一个软件，是完全依赖于硬件的，很多特性都是硬件原生支持，操作系统才能实现，比如特权级、保护模式、分页等），更深入地理解的什么是程序。

这些知识，在计算机任何领域，都有很大的作用，所以我花费大量时间深入学习操作系统，我认为非常值得！



## 4. 未来和展望

本系统只是一个非常精简的操作系统内核，并且还没有文件系统，非常不完善。

还有太多的内容可以完善，最基本的就是文件系统。

还有我也想实现GUI，可以用鼠标来操作（我记得有本书《30天自制操作系统》，那本书有实现GUI的，有时间我一定要把GUI移植到我这个系统中去）

还有本系统是32位的，我想能不能弄一个64位的，

还有一些硬件操作太老了，比如PIC可编程中断控制器8259A太老的，还有对硬盘的操作，使用的方式是程序查询和程序中断，没有使用DMA，太低效了，

还有用户进程只支持单线程，我也想实现多线程的用户进程，

再比如我这个系统只支持单核CPU，我想实现一个支持多核CPU的操作系统，

还有TCP/IP协议栈，那么就可以网络通信了，，

如果再移植编译器就更厉害了，，，，，，，，



所以我可以接着做的东西还有很多，有两个部分我计划后面一定要去实现：

- 文件系统
- GUI



另外，这个操作系统的实现只是我对操作系统刚刚入门，我对操作系统低层的学习永远不会停止，，甚至希望有一天，能为Linux内核开源社区做出贡献（可能我想多了）。



<br/>

<br/>

<br/>

本系统参考：《操作系统真象还原》



