# 中断

## 一、中断基本介绍

### 1.  什么是中断

在学习计算机组成原理时，有提到过关于I/O中断。在讲到I/O设备和主机信息传递时，有一种方式叫程序中断方式，就是CPU向I/O发起准备信号后继续执行原有程序，不用轮询I/O设备，当I/O设备准备好数据后，向CPU发起中断。

所以可以认为中断就是一种打断CPU的行为，是外部设备、软件和CPU交流的方式。

CPU每执行一条指令，就会去查看中断，如果有中断发起，就会去执行中断处理程序。

### 2. 中断的分类

中断就是发生某件事然后通知CPU去处理，所以把中断来源分类如下图：



![](https://i.loli.net/2021/04/01/DyfpmnCQeRd6NV3.png)



中断发起后就会去执行相应的中断处理程序。

#### 2.1 外部中断

外部中断，就是来自CPU外部设备的中断，中断源必须是硬件，因此也叫硬中断。

外部中断/硬中断根据中断的严重程度分为：可屏蔽中断和不可屏蔽中断。

##### 2.1.1 可屏蔽中断

可屏蔽中断，就是CPU可以选择屏蔽不去处理的中断。

对于外部设备而言，比如像硬盘、网卡发起的中断，就属于可屏蔽中断，因为这些中断CPU不去处理计算机也可以照样运行，相对来说没有那么严重。

至于是否将中断屏蔽，可以使用eflags控制寄存器的IF位来设置是否屏蔽中断。

> eflags的IF位是Interrupt Flag，如果为1表示CPU要屏蔽中断，如果为0表示接收中断。

###### 2.1.1.1上半部和下半部

这种类型中断没有那么紧急，并且发起的设备比较多，所以这样的可屏蔽中断还可以分成上半部和下半部。

把中断处理程序需要立即执行的划分到上半部，把那些不紧急的部分则会推迟到下半部。在CPU执行上半部中断处理程序时，CPU是关中断状态的，这样就不会被其他中断打断。

而在执行下半部中断处理程序时，CPU是开中断的状态。在执行下半部中断处理程序时，如果有新的中断发生，那么就会去执行新的中断的上半部。那么旧的下半部中断处理程序要之后等待CPU来调度。

##### 2.1.2 不可屏蔽中断

不可屏蔽中断，就是CPU不得不处理的中断，因为这种中断发生了不去处理系统可能无法运行。

比如内存读写错误，就是CPU无法读写内存了，这样的中断十分致命，因为CPU无法读写内存几乎干不了任何事情了。所以不得不处理，虽然大部分情况下也处理不了。

##### 2.1.3 外部设备如何跟CPU传递中断信息？

那么外部设备如何给CPU传递中断信息呢？这里是多个设备同类型的中断在硬件上共用一个信号线（**具体是怎样的呢？见下面的中断代理：可编程中断控制器8259A**，是所有硬件设备把中断信号发给中断代理，然后中断代理发给CPU）。

不同类型的中断使用的是不同的物理信号线。

**可屏蔽中断**使用的是**INTR**(INTerrupt)，表示一般的中断。

**不可屏蔽中断**使用的信号线是**NMI(**Non Maskable Interrupt)，表示致命的错误。

不同的中断有不同的中断号来区分，CPU根据不同的中断号去执行不同的中断处理程序。对于不可屏蔽中断，共用一个中断号，因为CPU无法处理不可屏蔽中断。

#### 2.2 内部中断

内部中断应该是说来自主机内部，主观上的。

内部中断分为：软中断和异常。<font color='red'>异常也是一种内部中断</font>。

##### 2.2.1 软中断

软中断由软件发起的中断。

比如软件可以发起一下几种中断：

1. ```int 中断号```：发起中断，比如系统调用。
2. ```int3```：调试断点指令。
3. ```into```：中断溢出指令。这里不要看成into这个单词了，而应该看成int o(interrupt overflow)。
4. ```bound```：检查数组索越界指令。这里的数组应该不是代码层面的数组，应该是比如查找描述符表那样的数组吧。
5. ```ud2```：undefined2，未定义指令。该指令表示某个指令无效，CPU无法识别，常用与软件测试，无实际用途。

**上述几种中断中，除了第1种，其他的又可以称为异常**。

##### 2.2.2 异常

异常是指令在执行期间CPU内部产生错误引起的。

<font color='dodgerblue'>异常是在运行时发生的错误，因此也是不可避免的，也会无视eflags中的IF位</font>。

这里的运行错误，是说指令语法方面的错误。比如执行除法指令，分母为0，会引发异常。还有，比如CPU无法识别某个机器码，也会引发异常。比如CPU把数据当成指令执行，可能会解码失败，抛出6号异常。

异常也可以按照轻重分成以下三种：

1. Fault，称为故障。是可以被修复的。发生此类异常时，CPU将机器状态恢复到异常之前的状态，然后调用中断处理程序，该中断处理程序的返回值还是那条导致异常的指令。
   也就是当处理完中断处理程序（通常中断处理程序会将该问题修复），接着去执行那条发生异常的指令。比如操作系统中的缺页异常page fault。
2. Trap，陷阱。说明掉入陷阱无法进行下去，导致CPU停了下来。所以发生该类异常，CPU去执行中断处理程序，中断处理程序的返回地址是导致Trap的指令的下一条指令。（不然重复执行指令掉入trap）
3. Abort，终止。一旦出现该类指令，CPU无法修复，程序也无法运行，操作系统为了自保，只能将该程序kill。我猜这就是平常某个应用无响应，然后强行终止的情况吧。

一些异常还会有单独的错误码，错误码用于报告异常在哪个段上发生的。

#### 2.3 总结

1. 对于比较严重的中断类型直接无视eflag的IF位，CPU必须去执行相应的中断处理程序。比如不可屏蔽中断、异常。
2. CPU将不同类型的中断统一管理，给每一个中断分配一个中断号，这就是中断向量。并且每一个中断都对应一个中断描述符，中断描述符用于找到中断处理程序，把所有的中断描述符放到一个中断描述符表中，使用中断号/中断向量作为表的索引值。

## 二、中断描述符表(IDT)

当触发不同的中断，然后要去执行相应的中断处理程序。中断处理程序是一段代码，因此根据中断描述符可以定位到对应的中断处理程序。

学习了段描述符在学习中断描述符就很容易了，它们非常相似，全局描述符表(GDT)是描述一块内存段，而中断描述符表是描述一段中断处理程序（中断处理程序也是放在内存中）。

中断描述符表中可以有中断描述符（中断门描述符），还可以有任务门描述符和陷阱门描述符。

### 1. 中断描述符

中断描述符用于描述一段中断处理程序，一段程序怎么描述呢？当然是指可以定位到该程序的位置。

#### 1.1 中断描述符的结构

中断描述符的结构和段描述符很类似，都是8个字节，然后有一些属性，并且有些属性表示的意义都是一样。

下面以中断门描述符的结构为例(不同类型的门描述符只有TYPE字段不一样)：

![ ](https://i.loli.net/2021/04/01/LxM8GCcBwgTSklK.png)

<p style="text-align:right">图片来自：《操作系统真象还原》</p>

中断描述符的一个主要的作用就是定位中断处理程序，因此根据中断门描述符的16-31位和0-15位、16-31位可以定位到中断处理程序代码段。

其他字段描述：

1. S字段。此处的S跟段描述符的S一样，表示是否系统段，此处为0表示系统段（段描述符中的S为1）。
2. TYPE字段。表示描述符的类型，对于S字段为0的系统段，TYPE可以确定某个系统段描述符类型，是调用门还是中断门或者陷阱门等。
3. DPL字段。表示门描述符的特权级。要想访问该中断门描述符，必须CPL 特权级大于等于门描述符的DPL特权级，即：
   数值上CPL <= 门描述符DPL。
4. P字段。P表示Present，表示是否在内存中。

对于S字段和TYPE取不同的值，表示不同类型的门描述符，具体如下：

![image-20210401164326485](https://i.loli.net/2021/04/01/x9put6yTOD7b1VS.png)

<p style="text-align:right">图片来源：《操作系统真象还原》</p>

中断描述符和段描述符十分类似，甚至一些字段的意义和位置都一样。

#### 1.2 中断向量表和中断描述符表

操作系统是由中断驱动的，在实模式下，并没有中断描述符表，而是中断向量表，实模式下，中断向量表放在低端1M的0~0x3ff地址处。

那么中断向量表和中断描述符表有什么区别：

1. 中断向量表只能固定放在0-0x3ff地址，而中断描述符表可以放在内存任意位置。
2. 中断向量表每个中断向量大小4字节，中断描述符表每个中断描述符大小8个字节。

### 2. 中断描述符表寄存器IDTR

中断描述符表放在内存的任意位置，肯定要有个固定的地方储存中断描述符表的地址。就像全局描述符表一样，有一个GDTR寄存器存放的是全局描述符表的地址。

那么中断描述符表的地址就放在IDTR寄存器中，IDTR寄存器的结构和GDTR寄存器结构一样。都是低16位表示表界限，高20位表示表基址。

结构如下图所示：

![](https://i.loli.net/2021/04/01/4jmdSAHiN5nCcTZ.png)

> 为什么表基址只用20位表示？不是一个地址有32位吗？
>
> ​		因为分页机制，4G的内存空间被分为了1M个页，因此20位可以就可以访问1M个页了。
>
> IDTR中放的IDT地址是物理地址还是虚拟地址？还需要页表映射吗？
>
> ​		暂不清楚

还有就是段描述符表（GDT）中的第0个描述符是无效的，在IDT中第0个有效。

### 3. 中断处理

中断发生到中断处理，比如外部中断，可以分为两个部分：

1. CPU 外部：中断发生时，外部设备的中断由**中断代理芯片**接收，处理后将该中断的中断向量号发送到CPU。
2. CPU内部：CPU执行该中断向量号对应的中断处理程序。

本节主要讲解CPU内部处理中断的过程。

> 至于在CPU外部，中断芯片接收中断部分，在下一节：**中断代理：可编程的中断控制器8259A**

#### 3.1 中断处理过程

一般步骤就是发起中断，然后去执行中断处理程序，那么把步骤拆分就是一下几个步骤：

1. CPU根据中断向量号定位中断门描述符。
2. CPU进行特权级检查。特权级要符合这样的条件：数值上，中断门描述符的特权级DPL <= 当前特权级CPL <= 中断处理程序DPL。
3. 执行中断处理程序。将门描述符中的 *中断处理程序目标代码段选择子* 加载到 CS寄存器中，把门描述符中的 *中断处理程序在目标代码段的偏移量* 加载到IP寄存器，然后开始执行中断处理程序。

#### 3.2 给出中断号定位到中断处理程序

从给出中断号，到执行相应的的中断处理程序，内存的访问情况如下图：

![image-20210401183743884](https://i.loli.net/2021/04/01/PeXzn524ahBxvOr.png)

<p style="text-align:right">图片来源：《操作系统真象还原》</p>

具体的流程如下图：

![](https://i.loli.net/2021/04/01/rU8GVs9leCxm3FB.png)

如果发生中断对应的是**中断门描述符**，那么标志寄存器中的eflags中的IF位被值为0，表示屏蔽其他中断，是为了避免中断嵌套。

如果发生中断对应的事**任务门描述符**或者是**陷阱门描述符**，那么IF不会置为0，也就是允许中断，也就是允许CPU响应更高级别的中断。



发生中断，去执行中断处理程序，也要提前把原来的CS、EIP和EFLAGS寄存器的值压栈保存，然后从中断返回iret就会把保存的寄存器的值弹出，恢复原先的值。

### 4. 中断发生时的压栈情况

上面说到，去执行中断处理程序，就像调用子程序一样，要保存CS、EIP寄存器的值，但实际上，有很多值要压栈保存。这一节就讨论，当去执行中断处理程序，要压栈保存那些东西。

在学习特权级中，说过不同的特权级使用不同的栈。而在发生中断去执行中断处理程序时，很多情况下是要转换特权级的。比如发起系统调用，从用户进程的代码，转去执行系统内核代码。

因此，在处理中断时，压栈情况要分两种：涉及到特权级变化 和 没涉及到特权级变化。

> 注意：
>
> ​		在处理中断时，要给CS寄存器赋值中断处理程序的选择子，给EIP寄存器赋值中断处理程序代码段的偏移地址。CS和EIP寄存器的值重新加载了，不管新的选择子和旧的选择子是不是同一个段，**CPU都会认为是段间转移，因此都是远转移。因此CS和EIP的值都会压栈保存。**

#### 4.1 涉及到特权级变化

在之前讲特权级时有说过，不同的特权级使用不同的栈，因此在切换特权级时，还要切换栈，也就是还要保存切换特权级之前的SS和ESP寄存器的值（因为SS和ESP就描述了一个栈）。

**那么把原先SS和ESP的值保存到哪里呢？当然是放入到新的栈中**。好家伙，把一个栈放到了另一个栈。

**如何认定特权级是否发生变化**呢？比较**CPL**和中断描述符中的选择子对应的**目标代码段描述符的DPL**，注意是比较目标代码段描述符的DPL，而不是中断描述符的DPL。

不多bb，假如在处理中断时，特权级由3变为0，那么哪些东西要压栈呢？

1. 由于特权级发生变化，因此把旧栈（特权级为3的栈）的SS和ESP压入新栈（特权级为0的栈）。SS是16位的，扩充为32位，高位补0
2. 在新栈中压入EFLAGS。
3. 由于切换了代码段，因此要压入CS和EIP。CS是16位的，压栈时，扩充为32位。
4. 有些异常有错误码，错误码可以定义异常发生在哪个段。因此把错误码ERROR_CODE压栈。

压栈后的结果如下所示：

![](https://i.loli.net/2021/04/01/IOyDKULsHb25GhQ.png)

SS_old和ESP_old表示旧的栈（特权级为3的栈）的值，SS_new和ESP_new是新的栈（特权级为0）的值。

#### 4.2 不涉及特权级变化

如果不涉及到特权级变化，那么就不用把SS和ESP压栈了。

那么压栈后的结果如下所示：

![](https://i.loli.net/2021/04/01/qhOacYeLoITy6Rb.png)

#### 4.3 栈弹出情况

在处理完中断处理程序，要返回到原先的程序，这时要把栈中的内容弹出，把寄存器的值恢复。会使用iret指令，iret指令意味着从中断返回，它是中断处理程序的最后一个指令。

**如果有错误码，处理器并不会主动跳过它的位置**，所以必须手动跳过错误码，也就是把ESP + 4。一般不用错误处理码。

## 三、中断代理：可编程中断控制器8259A

### 1. 8259A介绍

对于可屏蔽中断，是硬件发给CPU的中断，那么多个的外部设备怎样与CPU连接呢？前面说过，多个外部设备把中断发给 *中断代理* ，然后 *中断代理* 通过**INTR**线把中断发给CPU。

还有如果同一时间，发送了多个设备发送中断，那么CPU优先处理哪个中断呢？会像线程调度一样有优先级吗？

可屏蔽中断代理——可编程中断控制器8259A 就是负责处理来自硬件的中断，然后把要执行的中断给CPU。

8259A的功能：

1. 屏蔽外设中断
2. 给外设中断判优先级
3. 向CPU提供中断向量号（外设并不知道中断向量号，是操作系统给它赋予的）

还有就是，既然8259A名字中带了，“可编程”，那么表示可以使用软件控制。

<img src="https://gitee.com/imcgr/image_blog/raw/master/20210611204727.png" style="zoom:67%;" />

8259A是一个芯片，一个芯片有8个连接外设的接口，也就是只能接受8个设备的中断，明显太少了，所以通过级联的方式来扩展外设接口（级联方式就像是只有一个插孔，然后使用多个插座连着扩展。或者说级联就像是计算机网络中的多个集线器来扩展接口）。

如果多个8259A芯片级联，那么只有一个芯片是主芯片（Master），其他的芯片都是从芯片（Slave）。从芯片把中断传给主芯片，然后主芯片向上传递给CPU。

 如图所示：

<img style="width:20%" src="https://i.loli.net/2021/04/01/4a2TgRh6z5diMSL.png"/>

### 2. 8259A的内部结构

#### 2.1 8259A的内部结构介绍

如下图，是8259A的内部结构：

![image-20210401213447282](https://i.loli.net/2021/04/01/JxviK6XUrIgLlCQ.png)

<p style="text-align:right">图片来源：《操作系统真象还原》</p>

8259A芯片内部寄存器介绍：

- IMR: Interrupt  Mask Register 中断屏蔽寄存器。宽度是8位，用来屏蔽某个外设的中断。
- IRR: Interrupt Request Register 中断请求寄存器。宽度是8位，接受经过IMR过滤后的中断信号并锁存。该寄存器中是等待处理的中断。
- RP: Priority Resolver 优先级判别器。当有多个中断同时发生，判定并找出优先级最高的中断。
- ISP: In-Service Register 中断服务寄存器。宽度是8位，表示正在处理的中断。

信号介绍：

- INT: 中断信号。8295A芯片把中断信号发给CPU。
- INTA: INT Acknowlege 中断响应信号。CPU收到中断信号后，回复一个INTA中断响应信号给8295A芯片。

#### 2.2 8259A如何区分不同的外设接口

上面的寄存器，比如IMR，IRR， ISP是如何来区分来自不同IRQ接口的中断的呢？

这些寄存器的大小都是8位，并且一个8295A芯片只有8个接口连接外设，分别是IRQ0 ~ IRQ7，也就是寄存器中的8位每一位代表一个IRQ接口。因此把不同的位设置为0或者1，就可以控制不同的接口。





比如IMR是中断屏蔽器，用于屏蔽中断，里面有8位，假如这8位是：0000 0001，那么表示屏蔽了IRQ0接口。

又比如IRR是中断请求寄存器，用于表示正在发出中断请求的接口，假如这8位是：1110 0000,那么表示IRQ0 - IRQ4没有发起中断请求，而IRQ5 - IRQ7正在发起中断请求。

再比如ISP寄存器，表示当前正在处理的中断。比如这8位是：1000 0000，那么表示当前CPU正在执行IRQ7接口发起的中断。



对于IRR中断请求寄存器、PR优先判决器、ISP中断服务寄存器，就好比对应了进程调度中的就绪队列、进程调度器、正在执行的进程。

#### 2.3 不同中断请求判优

比如有多个中断请求发给8259A芯片，那么优先处理哪个中断呢？这就像是操作系统中学过的的线程调度，或者像是计算机组成原理中学过的总线判优。

>  《计算机组成原理》中总线判优
>
> ​		多个I/O设备连接在总线上，同一时刻多个设备想向CPU发信息，那么优先让哪个设备发出信息？
>
> ​		《计算机组成原理》中给出了集中式，有三种：链式查询、计数器计时查询、独立请求。
>
> ​		链式查询，就是挨个查询每个I/O接口，先查询到有请求的先处理。但是缺点是，总是离总线近的控制部件近的优先处理。
>
> ​		计数器计时查询，就是先访问计数器中的记录的I/O接口，一轮处理完后，计数器的值是上一轮结束的那个I/O接口的位置。
>
> ​		独立请求，每一个I/O接口都与控制部件有一条物理线路连接，然后控制部件有排队器，根据某种算法来实现优先级。

对于8259A芯片来说，中断的判优跟总线的判优使用的方法几乎一样。特别是链式查询和计数器查询。

#### 2.3 8259A和CPU交互过程

1. 当8295A有的接口发起中断请求，8295A会通过控制电路发送INT信号给CPU，CPU就知道有中断产生了。

2. CPU将手上的事情处理完，就回复一个INTA信号，表示CPU已经准备好。

3. 8295A寄存器收到信号后，就会把刚才挑选出来的优先级最高的中断在对应ISR寄存器的位设置为1，并且把该中断在等待队列IRR中对应的位设置为0（表示该中断要被处理了，就不用待在等待队列了）。
4. CPU再次发送INTA信号，表示需要中断向量号。
5. 8295A将中断向量号通过数据总线发给CPU。

> 注意：
>
> ​		对于外部设备，只会发起中断请求，并不知道中断向量号，也不知道中断代理8259A的存在。但实际上是中断代理8259A给每个IRQ接口分配的中断向量号。IRQ接口的中断向量号 =  起始中断向量号  + IRQ接口号。
>
> ​		所以我们要给每个IRQ接口分配中断向量号。



如果8259A的“EOI(End Of Interrupt)通知”被设置为“非自动（手动）模式”，那么中断处理程序执行结束后还要向8259A发送EOI代码（”向8259A发送EOI“是写在中断处理程序末尾处或者主函数中），8259A收到EOI后，将ISR寄存器中当前正在处理的中断对应的位设置为0。

如果“EOI通知“设置的是”自动模式“，那么8269A收到CPU发来的第二个INTA信号后（第二个INTA信号就是CPU索要中断向量号的那个信号），8259A就会在ISR寄存器中正在处理的中断的那一个位设置为0。

### 3. 对8259A的操作

8259A被称为可编程中断控制器，既然是可编程，就是可以使用软件控制的，那么怎样对8259A进行控制操作呢？

8259A内部一共有两组寄存器：

1. ICW: Initialization Command Word 初始化命令字，一共四个寄存器：ICW1~ICW4
2. OCW: Operation Command Word 操作命令字，一共三个寄存器：OCW1 ~ OCW3

通过操作8259A的这几个寄存器可以达到操作8259A的目的。

#### 3.1 ICW

ICW用于对8259A做初始化，用来确定是否需要级联、设置起始中断向量号、设置中断结束模式。而且<font color="red">必须依次写入ICW1、ICW2、ICW3、ICW4.（这里强调顺序，我猜是因为，有的ICW是共用一个端口号的）</font>。

##### 3.1.1 ICW1

ICW1用于初始化8259A的连接方式（单片或者多片级联）和中断信号的触发方式（电平触发或者边沿触发）。

ICW1要写入主片的0x20端口和从片的0xA0端口。

ICW1结构如图所示：

<img  width="50%" src="https://i.loli.net/2021/04/02/fOb4M6sQC5WEy78.png"/>

<p style="text-align:right">图片来源《操作系统真象还原》</p>

字段介绍：

- IC4：表示是否要写入ICW4。IC4为1，表示要写入ICW4，为0表示不需要。x86系统IC4必须为1。
- SNGL：SiNGLe。如果SNGL为1，表示单片，为0表示多片级联。
  如果多片级联，就涉及到主片和从片使用哪个接口互相连接的问题，因此SNGL为0，就要使用的ICW3。
- ADI：call ADdress Interval。用于设置8085处理器的调用间隔。x86不用。
- LTIM表示Level/edge Triggered Mode。用来设置中断检测方式，LTMI为0表示边沿触发，为1表示电平触发。
- 第4位固定为1，是ICW1的标记。
- 第5~7位专用语8085处理器，x86不需要。

##### 3.1.2 ICW2

ICW2用来设置起始中断向量号，前面说过，外设发起中断并不知道中断向量号的存在，中断向量号是中断代理8259A给每个IRQ接口设置的。

ICW2需要写入主片的0x21端口和从片的0xA1端口。

ICW2结构如下图所示：

<img width="50%" src="https://i.loli.net/2021/04/02/Lk8wVGF5pZRm37M.png"/>

<p style="text-align:right">图片来源《操作系统真象还原》</p>

前面讲过，IRQ接口的中断向量号 =  起始中断向量号  + IRQ接口号。

第3~7位一共5位，用于设置起始的中断向量号，第0~2位一共3位，不用管，就是IRQ的接口号。

##### 3.1.3 ICW3

ICW3仅在级联的方式下（ICW1中的SNGL为0）才需要，用来设置主片和从片使用哪个IRQ接口相连。

ICW3需要写入主片的0x21端口和从片的0xA1端口。

设置级联时，主片和从片是不一样的，因此对于主片和从片ICW3也有不同的结构。如下图所示：

<img width="50%" src="https://i.loli.net/2021/04/02/lUB2uJOcDkoM41m.png">

<img width="50%" src="https://i.loli.net/2021/04/02/bsr7pIRSkulNoUP.png">

<p style="text-align:right">图片来源《操作系统真象还原》</p>

主片的S0~S7，哪一位设置为1，那么这一位对应的IRQ接口就是连接的从片。

对于从片，只用到了低三位，用于描述从片和主片的哪一个接口连接了。比如从片与主片的IRQ2接口连接，那么主片的低三位就是101，也就是从片的ICW3就是0000 0101。

##### 3.1.4 ICW4

ICW4用于设置9259A的工作模式，当ICW1中的IC4位设置为1，才需要ICW4。

ICW4需要写入主片的0x21端口和从片的0xA1端口。

ICW4的结构如下图所示：

<img width="50%" src="https://i.loli.net/2021/04/02/rjJGKVOkEnLMaQR.png">

字段介绍：

- 第5-7位（高3位）为定义，置为0。
- SFNM: Special Fully Nested Mode 特殊全嵌套模式。为1表示特殊全嵌套模式，为0表示全嵌套模式。
- BUF: 缓冲模式。为1表示缓冲模式，为0表示非缓冲模式。
- M/S: Master/Slave设置主从片。如果是非缓冲模式，M/S无效。如果是缓冲模式，M/S为1表示是主片，为0表示是从片。
- AEOI: Auto End Of Interrupt 自动结束中断。前面讲过，8259A需要收到EOI信号才会结束中断。AEOI为1表示自动结束中断。
- uPM: 表示微处理器，为了兼容老的处理器。如果uPM为0表示8080或者8085处理器，为1表示x86处理器。


#### 3.2 OCW

OCW用于操作控制8259A，比如中断屏蔽和中断结束，OCW的发送顺序不固定，先发送哪个都行。

##### 3.2.1 OCW1

OCW1用来屏蔽该芯片来自外设的中断信号，实际上就是把OCW1写入了IMR寄存器。

OCW1写入主片的0x21端口或从片的0xA1端口。

OCW1结构如下图：

<img width="50%" src="https://i.loli.net/2021/04/02/erAwRuDSvFt5iM8.png">

M0~M7对应了IRQ0~IRQ7端口，哪一位设置为1，就是屏蔽哪个接口。

##### 3.2.2 OCW2

OCW2用来设置中断方式和优先级模式。

OCW2要写入主片的0x20或从片的0xA0端口。

OCW2结构如下图所示：

<img width="50%" src="https://i.loli.net/2021/04/02/E5zSFaLKvHy2eGh.png">

OCW2的字段R、SL、EOI组合可以有不同的方式。

- R: Rotation。R为1表示使用循环优先级，R为0表示使用固定优先级。
  其中循环优先级对应计算机组成原理的计数器计时查询，上一轮最后访问的的那个IRQ接口的优先级最高。
  固定优先级就是IRQ0最高，IRQ7最低。
- SL: Special Level 指定优先级。如果SL=1, R=1，那么L2、L1、L0可以指定某个IRQ接口优先级最低。比如L2、L1、L0是101，十进制就是5，那么IRQ5的优先级最低，优先级情况为IRQ5 < IRQ4 < IRQ3 < IRQ2 < IRQ1 < IRQ0 < IRQ7 < IRQ6 。
- EOI: End Of Interrupt 中断结束命令位。只有在ICW4中的AEOI为0才有效（即手动模式）。EOI为1, 8259A会将L0 ~ L2在ISR中对应的位清0。
- 第3~4位，是OCW2的标识。

OCW2的不同位组合比较复杂，不同的组合情况如下表：

<img src="https://i.loli.net/2021/04/02/o5VPmqDea23Gtig.png">

##### 3.2.3 OCW3

OCW3先不说了，懒得写了。

## 四、可编程计数器8253

可编程计数器8253可以控制时钟中断的发生频率。

通过操控计数器8253,可以控制时钟中断的发生频率和工作方式。

### 1. 8253内部结构

**8259A**的结构如下图所示：

![image-20210611165439382](https://i.loli.net/2021/06/11/izKauDNC7s2Rc69.png)

主要需要关注以下两个部件：

- 计数器
  - 真正计数的部件，倒计时一定时间，就会发生中断
  - 不同计数器之间互相独立
- 控制字寄存器
  - 用来控制计数器的计数值和工作方式等设置

图中不同的部件，有这不同的端口：

- 计数器0：0x40
- 计数器1：0x41
- 计数器2：0x42
- 控制器寄存器：0x43



**单个计数器**的内部结构如下：

![](https://gitee.com/imcgr/image_blog/raw/master/20210611200029.png)

- 计数初值寄存器（16位）
  - 保存计数器的初始值，开始计数之后跟它无关了
- 减法计数器（16位）
  - 真正计数的部件
- 输出锁存器（16位）
  - 把当前的值保存起来，让外界可以读取计数值

### 2. 8253寄存器控制字

可编程计数器是通过往**控制字寄存器(端口0x43)**写入数据来控制的，寄存器控制字格式如下：

![](https://gitee.com/imcgr/image_blog/raw/master/20210611201657.png)

其中工作方式，不同的工作方式有不同的属性，具体如下：

![](https://gitee.com/imcgr/image_blog/raw/master/20210611195512.png)



- 启动计数器开始计数的两个条件：
  - GATE引脚为高电平，即GATE 为1，这是硬件来控制的。【硬件条件】
  - 计数初值已经写入计数器中的减法计数器，这是软件使用out指令来控制。【软件条件】

- 硬件开启和软件开启
  - 硬件开启，软件条件已经满足，等待硬件条件满足
  - 软件开启，是硬件条件已经满足，等待软件条件满足
- 初始化8253的步骤：
  1. 往控制字寄存器所在的端口0x43写入控制字
     - 包括了要操控的计数器、读写方式、工作方式、数制格式
  2. 往指定的计数器端口写入计数初值
     - 比如往计数器0 (端口为0x40)写入初始值
     - **注意，控制寄存器设置，读写方式只能读写8位，所以16位的初值要分两次写入**

- <font color="red">本系统，控制字设置如下：</font>
  - 计数器：选择的是<font color="red">计数器0</font>
  - 读写方式：选择的是3号读写方式，也就是先读写低字节，后读写高字节
  - 工作方式：选择的是<font color="red">方式2</font>
  - 数值格式：选择的是<font color="red">0</font>，也就是<font color="red">二进制格式</font>
  - 因此控制字的值应该是：00 11 000 0










