## 计算机启动是如何加载操作系统的

我们都知道，操作系统也是一些指令，都是放在硬盘中的，操作系统又是如何被加载，谁来唤醒的？



### 1. BIOS

我们知道CPU只能从内存中取指令执行，由于内存中的RAM断电就会清除，因此，刚开机时，RAM是没有任何指令和数据的。

因此CPU只可能执行ROM中的代码。根据我们重装系统的经验，操作系统损坏或者进不去时，却可以进入BIOS，因此可以认为BIOS是比操作系统更加低层的系统。学计算机组成原理时，我就有猜测，是不是BIOS加载的操作系统？

事实上，当**开机时确实是先执行BIOS的代码的！**

这让我不禁又有几个疑问？

1. CPU是怎样知道BIOS的地址的？
2. 操作系统在硬盘里，BIOS怎样知道操作系统具体在哪个位置？

这先放一个实模式下的内存分部图(来自公众号：低并发编程)：

![memory](https://i.loli.net/2021/03/20/DVkM96Oyz1TCeIZ.png)

#### 1.1. BIOS的入口指令放在哪里？

BIOS的代码放在ROM中，那么CPU怎么知道要去哪里找指令？

学习计算机组成原理时，知道有个PC寄存器会保存CPU欲执行的指令地址，然后CPU去PC寄存器指向的地址取指令然后执行。

在x86系列的CPU中，这里的PC寄存器其实包含两个寄存器：CS寄存器和IP寄存器。

CS寄存器保存了段基址，IP寄存器保存段偏移地址，两个地址合成一个具体的地址。



但是BIOS的指令是放在ROM一个固定的地址的，所以要想执行BIOS的指令，必须去固定的地址取指令。这个固定的地址就是**```0xFFFF0```**。

**也就是在开机的一瞬间，CPU的CS:IP寄存器被强制初始化为```0xF000:0xFFF0```，这两个寄存器表示段基址和段偏移地址，合成就是```0xFFFF0```.**



因此，一开机，CS:IP的内容是```0xF000:0xFFF0```，CPU就会去这个地址取指令，然后执行。

#### 1.2 BIOS的指令是什么内容？

CS和IP被强制初始化为了```0xf000:0xfff0```，那么CPU会去```0xffff0```这里找指令，这里放的指令是什么呢？

根据内存分部图可知，实模式下，BIOS的范围是```0xf0000```~```0xfffff```，BIOS的执行的指令放在```0xffff0```，就还剩```0xf```大小的空间了，也就是16个字节的空间。

BIOS只留了16个字节的空间来放指令给CPU指令，那么放的是什么内容？

没错，BIOS的```0xffff0```地址，只有一条指令，那就是一条跳转指令：```jmp far f000:e05b```，所以地址```0xfe05b```才是BIOS真正发挥作用的地方。

执行到BIOS的```0xfe05b```地址的指令，BIOS会检测内存、显卡等外设信息，，自动在```0x00000```~```0x003FF```处建立中断向量表，自动填写中断例程。。。。。这一系列行为的指令都在BIOS中，操作系统不会干预。。。。

BIOS的代码难道就这样执行完了吗，当然不会，后面肯定要执行其他地方的指令。

### 2. MBR

我们写的程序、包括操作系统都放在硬盘中，因此BIOS代码在执行完毕之前，肯定要把CPU给让出去，会给谁呢？

接下来从硬盘中加载MBR并执行。

MBR表示Main Boot Record主引导记录，我的理解是，MBR相当于是操作系统的一个驱动，或者是加载操作系统过程中的一个过渡，或者是操作系统的一个标志（为什么是操作系统的标志，因为当检测到MBR就会知道有操作系统的存在）。

所以BIOS临死之前要去加载MBR。MBR是要自己编写，放在硬盘中的。那么是怎么知道MBR放在硬盘的哪个位置，又要把MBR加载到内存的哪个位置？

#### 2.1 MBR的位置

要让BIOS知道MBR放在哪里，只能把地址写死，定一套标准，所有的操作系统编写人员都遵循这个标准，把MBR放在硬盘固定的地方，然后加载到内存固定的地方。

所以MBR会固定放在硬盘的哪里呢？**MBR会固定放在是硬盘的0盘0道1扇区（首个扇区）**，也就是硬盘中最开头的位置。

> 至于扇区的标号，有两种描述方式：CHS和LBA
>
> CHS方式表示Cylinder(柱面)、Header(磁头)、Sector(扇区)。柱面从0开始，磁头可取0和1，扇区是从1开始的。
>
> LBA方式表示Logical Block Address逻辑块地址，即不考虑磁盘的物理结构，统一以块（扇区）来描述位置，0扇区、1扇区、2扇区.......100扇区.......。

那么会加载到内存哪个地方呢？**MBR会被加载到内存地址```0x7c00```处**。

至于MBR为什么要放在硬盘的0盘0道1扇区，为什么要加载到内存的```0x7c00```呢？MBR总得有个地方放吧？MBR总得加载到一个地方吧？放到其他地方你又要说为什么放在其他地方。。。。

#### 2.2 MBR的属性/局限

MBR放在硬盘的最开头部分，，如果有多个硬盘呢？

比如我们在重装系统时，先用一个U盘制作启动盘，然后插入电脑，重启电脑，进入BIOS，然后BIOS会自动检测到U盘是系统启动盘，那么BIOS怎么知道启动盘里面有没有操作系统呢？

所以MBR总得有什么特征吧？不然BIOS怎样识别MBR呢？

MBR的特征如下：

1. 放在硬盘的开头（0盘0道1扇区）
2. 大小只有512字节
3. 最后两个字节是0x55和0xaa（两个魔数）

因此BIOS临死前，校验启动盘的0盘0道1扇区内容，看有没有MBR，然后才能加载MBR。

从MBR的特征可以看到，**MBR有一个很大的局限性，那就是MBR只有512大小**，放不了多少指令（所以我认为，MBR就是一个标志，没干啥活），要想加载操作系统，还得加载个其他东西来过渡。

#### 2.3 MBR的使命

由于MBR的大小限制，加载操作系统的使命并不能给MBR了，所以加载操作系统这项使命给了Loader。

那么MBR呢，他的使命就是来加载Loader。

而Loader是由操作系统编写人员来写，也是放在硬盘中的，所以MBR要读取硬盘中，把Loader加载到内存，然后执行Loader。加载Loader也要知道Loader在硬盘的哪个位置，加载到内存的哪个位置才行。

#### 2.4 MBR制作

首先要编写MBR汇编代码，保存为```mbr.S```，由于mbr的代码是要到内存```0x7c00```处执行的，因此```mbr.S```内部都要以```0x7c00```为基址。

**把MBR烧录到硬盘中**：

先把```mbr.S```制作成二进制文件：

```shell
nasm -o mbr.bin mbr.S
```

MBR是放在第0盘0道1扇区的，使用dd命令把```mbr.bin```烧录到硬盘的0盘0道1扇区位置：

```shell
dd if=mbr.bin of=hd60M.img bs=512 count=1 conv=notrunc
```



### 3. Loader

MBR要读取硬盘中的Loader，然后把Loader加载到内存中，然后让CPU执行Loader。那么Loader放在硬盘的哪个位置？又要加载到内存的哪个位置？

#### 3.1 Loader的位置

MBR是我们自己编写的，所以要读取哪个硬盘，要放到哪块内存中，都可以自己定。因此Loader所在硬盘的位置可以自己定，加载到内存的地址也可以自己定。

MBR是放在0号扇区的（CHS是0盘0道1扇区，LBA是0扇区），这里就把**Loader放在2号扇区**（与MBR相隔一个扇区）。

MBR和Loader在硬盘位置如下：

![Loader](https://i.loli.net/2021/03/20/h4KEyWQArckUN18.png)

加载到内存的哪里呢？

这个也可以自己决定，这里就把Loader加载到```0x900```地址处。

#### 3.2 Loader的使命

Loader是要加载操作系统的，但是在加载操作系统之前，还要干很多事情。

比如**构建描述符表**、**进入保护模式**、**构建页表**、**加载内核**。。。。

这里每一个步骤内容都很多，理论知识也很多，就不在这里讲了，后面单独讲。

#### 3.3 Loader的制作

上面说了，Loader的内容很多，构建描述符表、进入保护模式、构建页表、加载内核等，这些都写好之后，就要把Loader烧录到硬盘中去。这跟MBR的制作差不多就不赘述了，不同的地方是，mbr烧录到0号扇区，loader要烧录到2号扇区。



### 4.总结

这里把上述的几个过程汇总一下，流程图如下：

![processLoadingOS](https://i.loli.net/2021/03/20/qcJtyPBwYodjAI4.png)



















