# 保护模式和段描述符
## 一、保护模式

### 1. 什么是保护模式

**保护模式是CPU的一种状态。**旧版本的CPU（8086）没有保护模式，从80286CPU开始，支持保护模式。为了区分，就把原来的叫做**实模式**，这个新的模式就叫**保护模式**。

> 注：保护模式是CPU硬件提供的，与操作系统无关。

### 2. 保护模式的作用

保护模式，顾名思义，重在“保护”二字。也就是，**保护模式可以更好地保护操作系统，提高了安全性**。

那么如何做到保护操作系统的呢？

先说下实模式的不足：

1. 实模式下操作系统和用户程序同一级别。也就是用户程序可以修改操作系统的代码。
2. 实模式下，用户程序引用的地址都是真实的物理地址。直接操纵物理地址很危险。
3. 实模式下只有20根地址总线，寻址范围只有1M。

对于1和2，是明显的安全性不足。对于3，是使用层面上的极大不方便。

实模式有如上很大的缺陷，也就产生了新的模式，也就是保护模式。所以现代操作系统的设计，都会从实模式进入到保护模式，再运行操作系统。

> 既然实模式这么辣鸡，保护模式为什么没有完全取代实模式呢？
>
> 就是为了兼容。实模式的CPU上运行实模式的操作系统。为了兼容，保护模式的CPU也可以运行实模式的操作系统。

### 3. 实模式和保护模式的区别

CPU从实模式进入到保护模式，有哪些变化呢？

#### 3.1 寄存器

保护模式的寄存器位数在实模式的基础上进行了扩展，主要是部分16位的寄存器扩展到了32位。如下图所示：

![实模式和保护模式寄存器](https://i.loli.net/2021/03/24/KBusJjaA3TCkbwt.png)

保护模式下，扩展为32位的寄存器加了一个E前缀。

#### 3.2 寻址范围

实模式下，寄存器大小是16位，地址总线是20根，寻址范围是1MB。

保护模式下地址总线是32根，寻址范围是4GB。

#### 3.3 地址计算

实模式下，地址是，保存在CS寄存器的基址左偏移4位，加上保存在IP寄存器的偏移地址，得到实际的物理地址。

保护模式下，CS寄存器放选择子，根据选择子，在描述符表中找到段描述符，得到段基址，然后加上偏移地址得到线性地址（如果没有开启分页，这里线性地址就是物理地址，如果开启了分页，线性地址就是虚拟地址，还有通过页表映射得到物理地址）。

#### 3.4 安全性

保护模式下分了四个特权级（0、1、2、3），有两个是我们熟悉的用户态（3）和内核态（0）。

### 4. 开启保护模式

开启保护模式有三步：

1. 打开A20地址线。
2. 加载GDT。给GDTR寄存器初始化。
3. 将cr0寄存器的pe位置为1。

开启保护模式很简单，也并不是关键，关键是准备工作。

## 二、段描述符

### 1. 什么是段描述符
段描述符，顾名思义，就是描述段的符号。

### 2. 段描述符的作用

段描述符，使用一些属性来约束某段内存，从而更好地实现保护的目的。

比如，防止用户程序破坏储存代码的内存区域，所以给内存段，添加“类型”属性，限制访问权限。

实模式下的用户程序和操作系统在同一级别，添加特权级属性，让操作系统和用户程序有不一样的权限。

### 3. 段描述符的内容

每一个段描述符8个字节大小，下面是一个描述符的结构：

![](https://i.loli.net/2021/03/24/vzqmpU3BSdcNI9k.png)

> 思考：
>
> ​	一个完整的地址才32位，但是这里段基址就有32位，要这么多干嘛？
>
> ​	答： 在保护模式下，不需要像实模式那样段基址左移然后加上偏移地址，而是直接加上偏移地址。
>
> ​			 因此在保护模式下，段基址和偏移地址都是32位的。



## 三、 全局描述符表

一个段描述符描述一个内存段，那么内存中这么多内存段，就需要多个段描述符。这些描述符都放在**全局描述符表**中。

### 1. 全局描述符表的结构

全局描述符表就像是一个数组，的结构如下所示：

![](https://i.loli.net/2021/03/24/HjioaqD5chXd7TS.png)

通过选择子中提供的索引，对应全局描述符表的下标，可以定位到一个具体的描述符，从而得到段基址，访问内存。

### 2. 全局描述符表寄存器GDTR

全局描述符表放在内存的地方，那么怎样访问到这个表呢？

就是通过全局描述符表寄存器（GDTR）来访问GDT，这个寄存器保存了全局描述符表的地址。

#### 2.1 GDTR的结构

GDTR的结构如下图所示：

![](https://i.loli.net/2021/03/24/q3LxNBpI261UMQO.png)

GDTR中前16位是GDT界限，后32位是GDT的起始地址。

#### 2.2 GDTR和GDT

GDT的地址范围是：GDT的起始地址 ~ (GDT的地址地址 + GDT界限)

**GDT界限只有16位，可以表示的地址范围是[0 ~ 65536]，而一个段描述符占8个字节，因此最多表示65536/8 = 8192个段描述符。**



描述符表包括全局描述符表GDT(Global Descriptor Table)和局部描述符表LDT(Local Descriptor Table)。

> 现在操作系统不使用LDT。为什么？

#### 2.3 GDT中第0个描述符

在GDT中，第0个描述符是不可用的。因为描述符在描述符表中，是根据选择子的索引值来定位的，如果选择子没有初始化，那么默认就是0，就会错误地访问到第0个描述符。

因此GDT中第0个描述符不可用，如果访问到的第0个描述符，处理器会发生异常。

### 3. 选择子

#### 3.1 什么是选择子

在实模式中，CS寄存器存放的是段基址，而保护模式下，段基址是放在段描述符中的，而**CS寄存器就用来存放选择子Sector**。

**选择子的作用是，给描述符表提供索引。**



#### 3.2 选择子的结构

选择子的结构如下图所示：

![](https://i.loli.net/2021/03/24/vWcjQDokTbtVUPl.png)

低两位(0-1)：RPL，Request for Privilege Level，请求特权级，可以表示0,1,2,3四种特权级。

第2位：TI, Table Indicator，表示选择子在GDT还是LDT中。TI为0表示在GDT中，TI为1表示在LDT中。

高13位(3-15)：表示描述表的索引值，根据索引值，可以定位描述符表中的元素。

> 为什么索引值只有13位？
>
> 选择子的索引值对应GDT的下标，或者说是GDT的内部偏移量。上面说到一个GDT最多有8192个段描述符，也就是GDT下标/偏移量最大为8191，使用13位刚好可以表示。



> 注：选择子高13位保存的是描述符表索引值（数组下标）！而不是描述符表项的偏移地址。

#### 3.3 选择子寻址过程

根据选择子定位到物理内存如下图所示：

![](https://i.loli.net/2021/03/24/37ZjlVC1QnubXzy.png)

1. 选择子的高13位是描述符的索引值，可以得到描述符表的下标。
2. 根据下标，可以取到描述符表中具体的描述符。
3. 取出描述符，可以再得到描述符中的段基址。
4. 根据段基址，可以得到物理内存的地址（如果没有开启分页）。

### 四、保护模式对内存段的保护

#### 1. 加载选择子时的保护

在往CS寄存器加载选择子时，会做一下几个方面的检查：

##### 1.1 检查选择子的索引值是否越过描述符表的边界

选择子的结构如下图：

![](https://i.loli.net/2021/03/25/jTQDL4cxAGzO5lV.png)

选择子的高13位保存了描述符表的索引值，相当于描述符表的下标，因此要检查下标是否越界。

当然，实际在检查过程中，是要算出选择子指向描述符表中描述符的地址，然后和描述符表的界限值比较，比较公式如下：

**描述符表基地址 + 选择子中的索引值 * 8 + 7 <= 描述符表基址 + 描述符表界限值。**

这里再看看描述符表中的内容：

![](https://i.loli.net/2021/03/24/HjioaqD5chXd7TS.png)

可以看到，描述符表中每个描述符都是8个字节，一个描述符的终止地址是：下标/索引值 * 8 + 7。

##### 1,2 检查段寄存器的用途和段描述符中的TYPE是否匹配

段描述符中的TYPE字段描述一个段的类型。在把一个段的地址加载到段寄存器中，CPU会检查段寄存器(CS、DS、ES、FS、GS、SS)的用途和该段的类型是否匹配，具体如下表：

<table style="text-align:center">
    <tr>
   	    <td rowspan="2">段寄存器</td>
        <td colspan="2">代码段(X=1)</td>
        <td colspan="2">代码段(X=0)</td>
    </tr>
    <tr>
        <td >只执行(R=0)</td>
        <td >执行+可读(R=1)</td>
        <td >只读(R=1, W=0)</td>
        <td >读写(R=1, W=1)</td>
    </tr>
    <tr>
    	<td>CS</td>
        <td >通过</td>
        <td >通过</td>
        <td >不通过</td>
        <td >不通过</td>
    </tr>
    <tr>
    	<td>DS</td>
        <td >不通过</td>
        <td >通过</td>
        <td >通过</td>
        <td >通过</td>
    </tr>
    <tr>
    	<td>ES</td>
        <td >不通过</td>
        <td >通过</td>
        <td >通过</td>
        <td >通过</td>
    </tr>
    <tr>
    	<td>FS</td>
        <td >不通过</td>
        <td >通过</td>
        <td >通过</td>
        <td >通过</td>
    </tr>
    <tr>
    	<td>GS</td>
        <td >不通过</td>
        <td >通过</td>
        <td >通过</td>
        <td >通过</td>
    </tr>
    <tr>
    	<td>SS</td>
        <td >不通过</td>
        <td >不通过</td>
        <td >不通过</td>
        <td >通过</td>
    </tr>
</table>
##### 1.3 检查段是否存在

检查完TYPE字段后，检查段描述符中的P位是否存在。

P为1表示存在，就会把选择子载入段寄存器中，并把段描述符缓冲寄存器更新为该选择子对应的段描述符的内容，并把该段描述符中的A位置为1，表示已经访问过了。

P为0表示不存在，可能是因为内存不足，操作系统把该段从内存移出到硬盘了。此时处理器会抛出异常，并去执行异常处理程序，该异常处理程序会讲该段从硬盘加载到内存，并把P位置为1，然后返回。CPU继续判断P位。

> 中断处理程序由操作系统来设置，因此这里把P位置为1，是操作系统来完成的。



> **这里的检查都是由CPU来完成，比如选择子越界检查、段类型检查、检查段是否存在。**



#### 2. 代码段和数据段的保护

对于代码段和数据段，CPU每访问一个地址，都要确认该地址没有超过所在内存段的范围。

段描述符中有个段界限属性，描述了段的大小，段描述符中还有G属性，表示粒度。

内存段边界是：(描述符中的段界限 + 1 ) * (段界限的粒度大小:4K或者1) - 1

那么访问地址是要确认没有超过边界。

也就是**CPU根据一个地址访问内存时，不能跨段**。








