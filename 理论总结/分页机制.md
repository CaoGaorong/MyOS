## 分页机制

### 1. 为什么要分页

比如，有ABCD四个进程在运行，占用内存空间如下图：

![](https://i.loli.net/2021/03/25/mgnEfU5BeoKXbRh.png)

当B和D运行完毕，内存空出来了，但是空余空间不是连续的，这时加入来了一个新的进程E，需要占用内存70M，由于内存中没有这么大的空间，因此进程E此时无法运行。



在产生地址时，是段基址+偏移地址构成线性地址，并且该线性地址直接对应物理地址，给出的线性地址都是连续的，因此物理地址也必须连续，所以就会导致上图的情况。



这种情况的本质是因为物理地址必须连续，因此只要让物理地址不连续即可解决。**如果线性地址连续，而物理地址不连续，就解决了**。**也就是需要建立一种映射关系，将连续的线性地址映射到不连续的物理地址**。

>  就像HashMap，key和value建立映射，根据key可以取出value。这里线性地址就像是key，物理地址就像是value。



要建立映射，有多种方式，如果写一种算法来建立映射，时间复杂度再低，效率都不如硬件。因此CPU给了硬件支持，由页表来建立映射关系，并且由CPU来查表。

> 查表由CPU来完成，页表内容由操作系统来完成。

> 逐渐深刻体会到软件发展确实限制于硬件。这么多功能都由CPU来提供，比如之前的保护模式，段描述符，这里的分页机制，都要硬件提供支持，然后软件与硬件相互配合。
>
> 从应用程序的角度看，操作系统就是一个黑盒子，操作系统把一些操作都封装起来成系统调用，应用程序通过系统调用来完成功能。
>
> 而从操作系统角度看，硬件是一个黑盒子，硬件也把一些低层的操作封装起来，然后操作系统调用硬件的“接口”来实现功能。
>
> 果然，计算机的世界都是一层一层的抽象，操作系统还不够低层。计算机的世界低层真的是量子力学吗？



### 2. 一级页表

页表是建立线性地址和物理地址的映射。那么页表该如何设计呢？

首先内存都是连续的，是无法建立映射的，**因此要将内存“分块”，然后页表项的每一项用于都保存一块内存空间的地址**。

那么“分块”分多大合适呢？

假如是1个字节，内存空间是4GB，那么就有4G个“块”，就有4G个页表项。每个页表项都保存一个地址，需要32位即4字节，那么4G个页表项需要4G*4B = 16GB大小的空间。显然内存放不下这么大的页表。

#### 2.1 页

将内存“分块”，这里的“块”，官方名称是“页”，CPU中采用的页大小是4KB。对于4GB的内存空间，每一页是4KB，那么一共可以分为1M个页。

也就是物理内存可以分成下面图所示：

![](https://i.loli.net/2021/03/25/LsD1nxTcud5ihwf.png)

#### 2.2 页表和页表项

4GB的物理内存分为了1M个物理页，那么页表就需要有1M个页表项。每个页表项都保存了一个物理地址，占用32位即4个字节。

一级页表和物理内存空间映射大致如下图：

![](https://i.loli.net/2021/03/25/lCxKDaWOHFu2fhq.png)

> 页表项在页表中通过索引访问，就像描述符表和段描述符一样。

总结页表、页表项、页的属性：

页：

​	页是物理内存块，标准大小是4KB，那么4GB的内存分为了1M个物理页。

页表项：

​	页表项保存的是物理页的地址，而32位的地址长度是4B，因此一个页表项大小是4B。

​	每一个有页表项都对应一个物理页，1M个物理页那么就需要1M个页表项来保存其地址。

页表：

​	页表是页表项的集合，包含了多个页表项。

​	一个页表有1M个页表项，一个页表项大小是4B，那么一个页表大小就是4MB。

> 思考：
>
> ​	页表项保存的是物理页的地址吗？内存中只有1M个物理页，干嘛要32位来表示？
>
> 解答：
>
> ​	页表项保存的不仅仅是物理页的地址（物理页只有1M个，20位用于保存物理页地址足够了），页表项还有其他东西。在讲到二级页表时有页表项的结构。

#### 2.3 页表的位置

分页机制开启前，要把页表的物理地址加载到控制寄存器cr3中。

> 分页开启前，线性地址就是物理地址。因此页表的物理地址很容易得到。

#### 2.4 访问物理地址流程

根据线性地址得到物理地址过程如下图所示：

![](https://i.loli.net/2021/03/25/3ASKeLfcXVigh6y.png)



### 3. 二级页表

#### 3.1 一级页表的缺陷

1. 一级页表最多有1M个页表项，每个页表项大小是4B，如果页表项全满就是4MB。
2. 一级页表必须要提前建好。
3. 每个进程都要有自己的页表，进程一多，花销比较大。

二级页表解决了上述问题，可以按照需要动态创建页表。

#### 3.1 二级页表的结构

先看下图，这种结构很容易理解：

![image-20210325171046358](https://i.loli.net/2021/03/25/zQNGtunXM6CmF9A.png)

这种结构是二级索引，先访问页目录表，然后访问页表，然后访问物理内存。

对于页目录表和页表的属性从图中都可以看的很清楚：

页目录表：

​		页目录表包含1K个页目录项，每个页目录项指向一个页表。

​		每个页目录项大小是32位，那么页目录表大小就是4B * 1K = 4KB

页表：

​		每个页表包含1K个页表项，每个页表项指向一个物理页。

​		每个页表项大小是32位，那么一个二级页表就是4B * 1K = 4KB。

一个物理页大小是4KB，一个二级页表占用的内存空间也是4KB，一个页目录表占用的空间也是4KB。

#### 3.2 页目录项和页表项的结构

之前只提到页目录项保存了第二级页表的索引，页表项保存了物理页的地址，但是页目录项和页表项结构是怎样的？

**其实，一个页目录项和页表项虽然占用32位，但是只有20位用来保存页表/物理页的地址**。页目录项和页表项结构如下图：

![](https://i.loli.net/2021/03/25/DsnaYrVJIPBXNRz.png)

对于图中的地址高20位，如果是页目录表项结构，那么这地址高20位指的是页表物理页的高20位；如果是页表项结构，那么这地址高20位指的是物理页高20位。

#### 3.3 cr3寄存器的机构

对于二级页表，页目录表的地址是放在cr3寄存器中的。由于页目录表占用内存空间是4KB（和一个物理页大小一样），所以**页目录表的物理地址是4K的整数倍，也就是低12位都是0，只需要保存高20位即可**。

cr3寄存器的结构如下图：

![](https://i.loli.net/2021/03/25/9bJ6M7LVBqQPvhA.png)

解释：

​		PWT和PCD位与页目录项/页表项中的PWT和PCD位一样，都是设置高速缓存，这里都设置为0。其他低位都没用，设置为0。

​		由于页目录表放在一个物理页中（都是4KB大小），因此只需要20位即可。

#### 3.4  二级页表访问物理地址的流程

给出线性地址得到物理地址，二级页表的寻址流程如下：

![](https://i.loli.net/2021/03/25/BNmOdFePvo2hbrJ.png)流程文字叙述如下：

1. 取出放在**cr3寄存器**中的**地址部分**(只有20位，<font color='red'>因此还需要左移12位，把低位空出来留给偏移地址</font>)，作为**页目录表**的基地址。
   然后取出<font color='dodgerblue'>线性地址的高10位</font>，作为**页目录表的<font color='red'>索引值</font>**，然后根据索引值，算出<font color='red'>表内偏移地址</font>（表内偏移地址 = 索引值 * 4）。
   然后页目录表基址 + 表内偏移地址 = 页目录项地址。
2. 取出放在**页目录项**中的**地址部分**(只有20位，<font color='red'>因此还需要左移12位，把低位空出来留给偏移地址</font>)，作为**页表**的基地址。
   然后取出<font color='dodgerblue'>线性地址的中间10位(第21-12位)</font>，作为**页表的<font color='red'>索引值</font>**，然后根据索引值，算出<font color='red'>表内偏移地址</font>（表内偏移地址 = 索引值 * 4）。
   然后页表基址 + 表内偏移地址 = 页表项的物理地址。
3. 取出**页表项**中的**地址部分**(只有20位，<font color='red'>因此还需要左移12位，把低位空出来留给偏移地址</font>)，作为**物理页**的基地址。
   然后取出线性地址的低12位，直接作为<font color='red'>页内偏移地址（不是索引值）</font>。
   然后 页表基址   + 页内偏移地址 = 最终物理地址。

总结：

1. 不管是页目录项中保存的地址，还是页表项中保存的地址都不是完整的地址，因为只有20位，还需要左移12位，构成32位的基地址。
2. 线性地址的高10位得到的是页目录表的索引值，中间10位得到的是页表的索引值，都需要乘以4，得到偏移地址。
3. 上述的1中得到的基地址 + 2中得到的偏移地址 = 完整的地址

​		

### 4. 启用分页机制

启用分页机制也只是一个开关，步骤如下：

1. 准备好页目录表和页表
2. 将页目录表地址的高20位放到cr3寄存器的高20位。(为什么是20位？因为只需要20位就行了)。
3. 把寄存器cr0的PG位置为1。

### 5. 页目录表和页表的内存布局

页目录表和页表都是放在内存中的，那么这两种表怎么放呢？

这里把页目录表放在起始位置是```0x100000```处，内存布局如下图：

![image-20210326142939644](https://i.loli.net/2021/03/26/OHmj7FRCNYxfwrh.png)



#### 5.1 内核空间映射

在设置虚拟地址和物理地址的映射时，有一下几个需求：

1. 内核在物理地址的内存低端1MB（就是实模式的寻址范围）。
2. 要把内核映射到虚拟地址的3GB以上。这是为了共享操作系统，用户进程在虚拟地址的3G以内，操作系统在虚拟地址的3GB~4GB，这样不同的用户进程访问到的是同一个操作系统。

对于第1点，内核放在内存低端1MB，为了保证**分页前的线性地址**，和**分页后的虚拟地址对应的物理地址**一致，因此把第0个页目录项保存第0个页表的地址，然后第0个页表保存物理地址的低4MB（包含了实模式下的低1MB）。

对于第2点，为了把内核映射到虚拟地址的3GB以上的地址，也就是要把低1MB的物理地址（内核放在低1MB）映射到3G以上的虚拟地址。所以页目录表的第768项（一个页目录项对应一个页表包含1K个物理页，那么一个页目录项就是1K*4KB = 4MB，那么页目录项第768项地址就是4MB * 768 = 3GB）映射到第0个页表，然后第0个页表映射到低1MB的物理地址。



上述两点画出图就如下：

![](https://i.loli.net/2021/03/26/x912WXD3aMsjyYi.png)

如上图所示，访问虚拟地址0~0x3F FFFF （低端4MB）地址，访问的物理地址也是0~0x3F FFFF（低端4MB）。

#### 5.2 使用虚拟地址访问页表本身

开启分页之后，给出的线性地址都是虚拟地址，访问内存要通过虚拟地址来访问。

如上图已知页目录表的物理地址是```0x0010 0000```，怎样通过虚拟地址来访问该页目录表呢？

这里一个小技巧：**让页目录表的第1023项（最高的一个页目录项）指向自己**。如下图所示：

![](https://i.loli.net/2021/03/26/MqhsBFZk3GWe2pn.png)



可以得到如下几个虚拟地址与物理地址的映射：

1. 0xffc0 0000 - 0xffc0 0fff  => 0x0010 1000 - 0x0010 1fff
2. 0xfff0 0000 - 0xfff0 0fff  => 0x0010 1000 - 0x0010 1fff
3. 0xffff f000   - 0xffff ffff  =>  0x0010 0000  - 0x0010 0fff

对于映射1，0xffc0 0000 - 0xffc0 0fff  => 0x0010 1000 - 0x0010 1fff。

0xffc0 0000 转成二进制是：【1111 1111 11】【00 0000 0000】 【0000 0000 0000】

发现高10位都是1，其他位都是0。高10位是页目录表的索引值，1111 1111 11换成十进制就是1023，也就是访问1023号页目录项。

中间十位都是0，表示索引值是0，由于1023号页目录项指向0号页目录项，因此索引值0访问的还是自己页目录表的页目录项0。

低12位都是0，表示偏移地址是0，上一步访问的事页目录项0，得到页表0的物理地址，加上偏移地址0，最终得到页表0的物理地址。

所以**使用虚拟地址0xffc0 0000可以访问到页表0的物理空间**。



对于映射2，0xfff0 0000 - 0xfff0 0fff  => 0x0010 1000 - 0x0010 1fff。

0xfff0 0000转成二进制就是：【1111 1111 11】【11 0000 0000】【0000 0000 0000】。

高10位都是1，跟映射1一样，访问页目录项1023，还是访问页目录表本身。

中间10位是11 0000 0000，换成十进制就是768，也就是访问页目录表的768项，保存的是访问页表0的地址。

低12位都是0，表示偏移地址是0，也就是最终得到的是页表0的物理地址。

所以**使用虚拟地址0xfff0 0000可以访问到页表0的物理空间**。



对于映射3，0xffff f000   - 0xffff ffff  =>  0x0010 0000  - 0x0010 0fff。

0xffff f0000转换成二进制就是：【1111 1111 11】【11 1111 1111】【0000 0000 0000】。

高10位是1，跟前面一样，访问页目录项1023，保存的是页目录表本身的地址。

中间10位，换成十进制是1023，也就是访问页目录表的第1023项，保存的还是页目录表自身的地址。

所以**使用虚拟地址0xffff f000可以访问到页目录表的物理空间**。





