# 特权级

## 1. 特权级简介

操作系统为用户进程提供低层的基础，但是操作系统却不会被用户进程修改，大家都是指令，为什么应用程序不能修改操作系统呢？

这正是提现了保护模式的对操作系统的“保护”，这样操作系统才更安全。用户进程无法修改操作系统正是因为操作系统的特权级比用户进程的特权级高。

在之前的段描述符的结构、选择子的结构都有一个特权级字段，有0级、1级、2级、3级，数字越小，权力越大。

## 2.  TSS

TSS即Task State Segment，意为任务状态段，是处理器在硬件上原生支持多任务的一种实现方式（虽然操作系统不用这种方式）。

TTS是一种数据结构，是一个任务的标识。

> 任务和进程有何区别？
>
> ​		没有操作系统的情况下，可以认为进程就是任务，任务就是一段在处理器上运行的程序。
>
> ​		但是有了操作系统，一个任务可能包含多个进程。一个任务分成用户部分和内核部分。

TTS的结构如下图所示：

<img src="https://i.loli.net/2021/03/26/9IdDlZBXvEoRmUh.png" width="50%"/>

TSS描述的是一个任务，我们可以看到有很多字段是寄存器比如gs、fs、ds等，就是该任务运行时这些寄存器的值。

这里看下TTS低地址处，有三组栈寄存器：ss0和esp0、ss1和esp1、ss2和esp2。

这三组栈寄存器的值分别表示：0特权级下的栈底和栈顶指针、1特权级下的栈底和栈顶指针、2特权级下的栈底和栈顶指针。**这几个值都是提前赋值好的，都是已知的**。

至于这几个寄存器有什么用，是在变换特权级是使用的。

## 3. 特权级的转换

不同的操作需要不同的特权级，所谓特权级的转换，是**CPU的特权级的变换**。那么一个用户进程（低特权级）怎样访问高特权级的数据呢？

对于特权级的变换有两种：

1. 低特权级转向高特权级。使用中断门、调用门等手段。
2. 高特权级转向低特权级。调用返回指令retf、iret。

### 3.1 从低特权级转向高特权级

处理器从低特权级转向高特权级，要把高特权级的栈地址加载到CPU的ss和esp寄存器中。那么高特权级的栈地址在哪里呢？就在TTS中。

比如当前用户进程特权级是3级，现在需要转向0特权级，那么需要把0特权级的栈（ss0和esp0，查询当前任务的TSS即可得）加载到CPU的ss和esp寄存器中。

### 3.2 从高特权级转向低特权级

从高特权级转向低特权级，只有一种情况，就是调用返回指令retf、iret。

## 4. DPL、CPL和RPL

DPL是段描述符中的一个属性，表示Descriptor Privilege Level，即描述符特权级，也就是**段内存的特权级**。

**CPL(Current Privilege Level)表示CPU当前状态的特权级**，一般当前特权级就是**当前CPU的CS和IP寄存器指向的指令的特权级（一致性代码段除外，CPU从低特权级去执行一致性代码段（高特权级），CPL不变）**。而指令就是代码段中的代码，也是放在内存段中的。因此**CPU的CPL就是当前正在执行的代码段中的DPL**。

RPL(Request Privilege Level)表示真正资源请求者的特权级。无法改变。

比如某个人打游戏技术很菜（RPL是3），但他氪金之后装备变得很好别人都以为他是大神（CPL提升为0），但他去当主播（访问DPL为0的资源）还是会被拒绝。

### 4.1 CPU访问内存时的特权级

#### 4.1.1 如果该段是数据段

如果一个段是数据段，该段要被访问。那么访问者（CPU）要访问该段中的数据，**访问者CPU的当前特权级（CPL）必须高于或等于该段的特权级（DPL）**。也就是数值上**CPL <= DPL**（特权级数值上越小，特权级越大）。

#### 4.1.2 如果该段是代码段

如果该段是代码段，CPU访问代码段，就是执行该段的代码指令。或者说是**CPU访问代码段，是指从当前执行的代码段转移到受访者的代码段上去执行**。

访问者和被访问者在不同的特权级下，是什么样的规则呢？

##### 4.1.2.1 一致性代码段

一致性代码段，在段描述符中，如果该段为非系统段（段描述符的S为0），type字段中的C位为1，就是一致性代码段。

一致性代码段也被称为依从代码段，Conforming，用于**实现CPU从低特权级代码的执行向高特权级代码执行的转移**，但是<font color='dodgerblue'>转移后的CPL并不会变，仍然是低特权级</font>。

所以访问一致性代码段的要求是，CPU的当前特权级（CPL）小于目标代码段的特权级（DPL），也就是数值上CPL  >=  一致性代码段的DPL。

> 为什么低特权级CPL可以访问高特权级的一致性代码段？并且访问后CPL还不能提高？
>
> ​		在我的理解下，一致性代码段是**特意**留给低特权级的CPU访问的，但是又不想提高CPU的当前特权级（CPL）。

##### 4.1.2.2 非一致性代码段

对于非一致性代码段，访问者的当前特权级（DPL）和被访问者的特权级（DPL）要相等才行，数值上：**CPL == DPL**。

> 低特权级不能访问高特权级可以理解，为什么高特权级也不能访问低特权级呢？
>
> ​		因为低特权级可以做的，高特权级也可以做，，所以CPU完全不屑于在高特权级下去执行低特权级的指令。。。
>
> ​		并且，如果CPU在高特权级下，去执行低特权级的代码段，那么去执行后，CPU的当前特权级（CPL）不就变低了吗？因为CPL		是CPU当前执行的代码段的DPL。



### 4.2 门

用户进程（特权级是3）在运行，CPU的当前特权级（CPL）也是3，那怎样提高CPU的当前特权级（CPL）呢？

在我看来，**“门”结构就是硬件提供给用户进程提高CPL的渠道**，不然CPU无法访问高特权级的代码段，永远无法提升CPL。

通过调用门，用户进程可以提高CPU的当前特权级（CPL），让CPU有更高的权限。



### 4.3 CPL和RPL缺一不可

说到CPL和RPL似乎很懵，两者似乎差不多，为什么要弄两个出来呢？

还有如果RPL特权级很低，那么CPL特权级在高，似乎也不能访问高特权级资源，那么CPL这么高有啥用呢？

我认为，要理解该问题，关键在于：<font color="red">CPU的CPL其实不是人为控制的，而是CPU在执行什么样DPL的代码，CPU的CPL就是什么样</font>(一致性代码段除外)。

#### 4.3.2 假如去掉RPL

如果**用户进程调用系统服务（提高了CPU的当前特权级）去执行某个操作，CPL特权级变高了，那这样不就为所欲为了**？可以任意操作任何资源，甚至修改内核了？

所以RPL不能去掉，RPL表示用户进程的原始特权级，因此<font color='red'><b>用户进程即使调用系统程序，提高了CPL，但是RPL仍然很低，所以访问高特权级资源会被拒绝</b></font>。

#### 4.3.1 假如去掉CPL

既然有了RPL，干脆不要CPL，访问资源时直接比较RPL和目标资源的DPL不就行了吗？

其实不然，RPL最大的缺点，<font color="red"><b>就是RPL可以被用户进程伪造，RPL是放在选择子中的，如果用户伪造RPL，那么不就为所欲为了吗</b></font>？

但是RPL的特点在于，<font color="dodgerblue"><b>如果用户进程请求系统服务，那么选择子中的RPL是操作系统设置的</b>，也就是**伪造RPL**和**调用系统程序**不可兼得</font>。

#### 4.3.1 同时使用CPL和RPL

所以，<font color="dodgerblue"><b>所以CPL和RPL缺一不可</b></font>。

如果用户进程伪造了RPL，就不能调用系统程序（否则就会被操作系统打回原形），而不调用系统程序，CPL特权级就无法提高，因此无法访问高特权级的资源。

如果用户进程不伪造RPL，调用了系统程序，但是因为RPL特权级太低，也无法访问高特权级资源。

所以CPL和RPL才同时制约了用户进程的特权级。

### 5. 特权级规则总结

![](https://i.loli.net/2021/03/27/KGFPnWiLB6C129x.png)





### 6. I/O特权级

前面讲的是CPU访问数据段、代码段是特权级的限制规则，数据段和代码段都是在内存中的，那么访问I/O外设有没有特权级规则呢？

#### 6.1 IOPL

eflag寄存器是CPU中的标志寄存器，在8086CPU叫flag寄存器。

结构如图所示：

![image-20210327170454065](https://i.loli.net/2021/03/27/v2dgqcC4rxt9zV7.png)

eflag每一位都是一个标志，比如CF表示Carry Flag，如果为1，那么标志着发生进位或者借位。

这里有个IOPL位，表示I/O Privilege Level，即I/O特权级。

程序想要操作某个I/O端口，那么数值上要：CPL <= IOPL，如果特权级比IO特权级高，那么可以操作所有的I/O端口。

但是如果当前特权级比I/O特权级低，如果目标端口在用户进程的“白名单”内，也可以访问，那么怎样在“白名单”内？

#### 6.2 I/O位图(bit map)

位图就是bit map，map表示映射，也就是建立某种对应关系。bit map就是把一个bit，映射到某个实际的对象。这里的I/O位图就是把一个bit映射到一个端口。

比如第0个bit表示第0个端口，第1个bit表示第1个端口。如果第0个bit是1，那么表示第0个端口可以访问。

Intel处理器最大支持65536个端口，使用bit map来对应就是需要65536个bit，65536 bit = 8192 byte。也就是一个位图占用8192个字节。

位图是放在TSS中的，但是TSS不是一定要有位图，所以TSS的大小不是固定的。

如下图，TSS和位图：

![image-20210327172401008](https://i.loli.net/2021/03/27/tS8M5RehAWap6LY.png)

所以某个任务在执行时，需要读写I/O端口，如果CPL特权级比IO特权级低的话，就会查看I/O位图，看要读写的特定端口在位图中是不是为0，为0表示”开了白名单“允许访问。



























