## boot.inc文件讲解

### 1. 文件介绍

```boot.inc```文件是用于系统启动时配置的常量文件。

### 2. 文件内容

```assembly
;-------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900 
LOADER_STACK_TOP equ LOADER_BASE_ADDR
LOADER_START_SECTOR equ 0x2

KERNEL_BIN_BASE_ADDR equ 0x70000
KERNEL_START_SECTOR equ 0x9
KERNEL_ENTRY_POINT equ 0xc0001500

;-------------   页表配置   ----------------
PAGE_DIR_TABLE_POS equ 0x100000

;--------------   gdt描述符属性  -----------
DESC_G_4K   equ	  1_00000000000000000000000b   
DESC_D_32   equ	   1_0000000000000000000000b
DESC_L	    equ	    0_000000000000000000000b	;  64位代码标记，此处标记为0便可。
DESC_AVL    equ	     0_00000000000000000000b	;  cpu不用此位，暂置为0  
DESC_LIMIT_CODE2  equ 1111_0000000000000000b
DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2
DESC_LIMIT_VIDEO2  equ 0000_000000000000000b
DESC_P	    equ		  1_000000000000000b
DESC_DPL_0  equ		   00_0000000000000b
DESC_DPL_1  equ		   01_0000000000000b
DESC_DPL_2  equ		   10_0000000000000b
DESC_DPL_3  equ		   11_0000000000000b
DESC_S_CODE equ		     1_000000000000b
DESC_S_DATA equ	  DESC_S_CODE
DESC_S_sys  equ		     0_000000000000b
DESC_TYPE_CODE  equ	      1000_00000000b	;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  
DESC_TYPE_DATA  equ	      0010_00000000b	;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.

DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00
DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b

;--------------   选择子属性  ---------------
RPL0  equ   00b
RPL1  equ   01b
RPL2  equ   10b
RPL3  equ   11b
TI_GDT	 equ   000b
TI_LDT	 equ   100b


;----------------   页表相关属性    --------------
PG_P  equ   1b
PG_RW_R	 equ  00b 
PG_RW_W	 equ  10b 
PG_US_S	 equ  000b 
PG_US_U	 equ  100b 


;-------------  program type 定义   --------------
PT_NULL equ 0

```

### 3. 内容详细说明

```assembly
;-------------	 loader和kernel   ----------
;LOADER_START_SECTOR是loader所在的硬盘扇区，这里是2，就是loader在2号扇区（LBA方式）
LOADER_START_SECTOR equ 0x2
; LOADDER_BASE_ADDR是loader要加载到内存的地址，这里是0x900，也就是要把loader加载到0x900内存地址处
LOADER_BASE_ADDR equ 0x900 
; LOADER_STACK_TOP表示栈顶指针的位置，这里和LOADER_BASE_ADDR一样，也就是Loader下面的空间就是栈
LOADER_STACK_TOP equ LOADER_BASE_ADDR

; KERNEL_START_SECTOR也就是内核KERNEL所在的硬盘是第9扇区(LBA方式)
KERNEL_START_SECTOR equ 0x9
; KERNEL_BIN_BAES_ADDR表示内核kernel要加载到的内存地址，这里是要把内核加载到0x70000地址处
KERNEL_BIN_BASE_ADDR equ 0x70000

; 这里其实少了KERNEL_STACK_TOP equ 0x9f000

; 内核代码开始的虚拟地址，这里是0xc0001500
; 为什么是虚拟地址0xc0001500？
; 虚拟地址0xc0001500对应的物理地址是0x1500
; 为什么选中物理地址0x1500？
; 因为Loader在内存的0x900处，预计Loader不会超过2000个字节，所以内核Kernel就放在了物理内存0x1500处
KERNEL_ENTRY_POINT equ 0xc0001500

;-------------   页表配置   ----------------
; 页目录表的起始位置在0x100000，就在实模式最大范围的1M上面
PAGE_DIR_TABLE_POS equ 0x100000 

;--------------   gdt描述符属性  -------------
; 先介绍下段描述符的结构：
; 低32位：
; 0-15：段界限的0-15位，这里设置为了1
; 16-31：段基址的0-15位，这里设置为0

; 高32位：
; 0-7：段基址的16-23位，这里直接设置为了0。
; 8-11：TYPE字段，这里使用DESC_TYPE_CODE表示代码段，DESC_TYPE_DATA表示数据段
; 12：S字段，表示是系统段还是非系统段，DESC_S_sys表示系统段，DESC_S_DATA表示非系统段
; 13-14：DPL字段，表示Descriptor Privilege Level，表示权限，DESC_DPL_0表示0级权限。。。。
; 15：P字段，表示段是否存在
; 16-19：段界限的16-19位，这里是DESC_LIMIT_CODE2或者DESC_LIMIT_DATA2或者DESC_LIMIT_VIDEO2
; 20：AVL字段，Avaliable，表示是否可用。DESC_AVL为0,表示不可用。
; 21：L字段，表示代码段是64位还是32位，DESC_L为0,表示32位。
; 22：D/B字段，对于代码段来说，该位是D，表示指令的有效地址位数和操作数位数，D为0表示16位，D为1表示32位，这里DESC_D_32表示32位。
;			  对于栈段来说，该位是B，表示操作数的大小，B为0表示栈使用IP寄存器，操作数是16位，，B为1表示栈使用EIP寄存器，32位。
; 23：G字段，表示粒度，G为0表示粒度为1B，G为1表示粒度是4KB。粒度配合段界限，粒度是段界限的单位。这里DESC_G_4K表示粒度是4K。
; 24-31：段基址的24-31位


; DESC_G_4K表示 把G位值为1，那么段界限的单位是4KB；这里段界限是1M(20位全是1)，段界限也就是4GB
DESC_G_4K   equ	  1_00000000000000000000000b   
; DESC_D_32表示有效地址和操作数都是32位。
DESC_D_32   equ	   1_0000000000000000000000b
;  64位代码标记，此处标记为0便可，表示32位
DESC_L	    equ	    0_000000000000000000000b	
; DESC_AVL，cpu不用此位，暂置为0  
DESC_AVL    equ	     0_00000000000000000000b	
; DESC_LIMIT_CODE2 代码段的段界限的第二部分
DESC_LIMIT_CODE2  equ 1111_0000000000000000b
; DESC_LIMIT_DATA2 数据段的段界限的第二部分
DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2
; DESC_LIMIT_VIDEO2 显存段的段界限的第二部分
; 为什么这里是0呢？
DESC_LIMIT_VIDEO2  equ 0000_000000000000000b
; DESC_P是段描述符的P字段，表示该段是否存在
DESC_P	    equ		  1_000000000000000b
; 0级权限
DESC_DPL_0  equ		   00_0000000000000b
; 1级权限
DESC_DPL_1  equ		   01_0000000000000b
; 2级权限
DESC_DPL_2  equ		   10_0000000000000b
; 3级权限
DESC_DPL_3  equ		   11_0000000000000b
; DESC_S_CODE表示段描述符的S字段，该字段为1表示非系统段
DESC_S_CODE equ		     1_000000000000b
DESC_S_DATA equ	  DESC_S_CODE
; DESC_S_sys 表示段描述符S字段，该字段为0,表示是系统段
DESC_S_sys  equ		     0_000000000000b
; DESC_TYPE_CODE表示段描述符的TYPE字段，表示段的类型，这里表示是可执行的代码段
DESC_TYPE_CODE  equ	      1000_00000000b	;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  
; DESC_TYPE_DATA表示可读可写的数据段
DESC_TYPE_DATA  equ	      0010_00000000b	;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.

; DESC_CODE_HIGH4 表示段描述符高4个字节(32位)
; 可以得出一下几个重要的属性：
; 	  第24-31位是0,也就是段基址的的24-31位是0
;     第0-7位是0，也就是段基址的16-23位是0
;	  (剩下的段基址在全部的低4个字节中)
; 
DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00
DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b

;--------------   选择子属性  ---------------
; 选择子的结构如下：
; 第0-1位：RPL
; 第2位：TI，Table Indicator

RPL0  equ   00b
RPL1  equ   01b
RPL2  equ   10b
RPL3  equ   11b
TI_GDT	 equ   000b
TI_LDT	 equ   100b

```

