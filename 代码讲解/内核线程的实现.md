[toc]

# 操作系统实战：内核线程

## 一、执行流

### 1. 执行流

所谓程序，就是一堆代码，一堆指令，让CPU执行，然后可以有不同的行为。当程序执行起来，就是进程。

所以程序按照顺序执行，也就是可以看做执行流， 多个线程并行，可以看成多个执行流。

不同的执行流可以并行，所以必须是独立的，所以不同的执行流应该有自己独立的上下文环境。

### 2. 程序和进程

常说，程序是静态的，进程是动态的，本质上，所谓的<font color="dodgerblue">线程/进程</font>，就是<font color="dodgerblue">静态代码块</font> + <font color="dodgerblue">上下文环境</font>。

<font color="red">所以线程/进程是一套机制，此机制可以让代码块创造它所依赖的环境。</font>

### 3. 进程和线程

进程 = 线程 + 资源

后面会说到，一个进程会有一个独立的页表，该进程下的线程，共享该页表。所以进程就是线程加上资源。

**线程才是执行流**，**线程不能脱离进程单独存在**，线程和用到的资源组成进程。

## 二、内核线程

### 1. PCB

进程就是静态代码块 + 上下文环境，所以每个**线程**都要有一个保存上下文环境的数据结构，这就是PCB。

```c
/* 进程或线程的pcb,程序控制块 */
struct task_struct
{
    uint32_t *self_kstack; // 各内核线程都用自己的内核栈
    pid_t pid;
    enum task_status status;
    char name[TASK_NAME_LEN];
    uint8_t priority;
    uint8_t ticks; // 每次在处理器上执行的时间嘀嗒数
    uint32_t elapsed_ticks; // 此任务自上cpu运行后至今占用了多少cpu嘀嗒数, 也就是此任务执行了多久
    struct list_elem general_tag; // general_tag的作用是用于线程在一般的队列中的结点
    struct list_elem all_list_tag; // all_list_tag的作用是用于线程队列thread_all_list中的结点
    uint32_t *pgdir;                              // 进程自己页表的虚拟地址
    struct virtual_addr userprog_vaddr;           // 用户进程的虚拟地址
    struct mem_block_desc u_block_desc[DESC_CNT]; // 用户进程内存块描述符
    pid_t parent_pid;                             // 父进程pid
    int8_t exit_status;                           // 进程结束时自己调用exit传入的参数
    uint32_t stack_magic;                         // 用这串数字做栈的边界标记,用于检测栈的溢出
};
```

- 给1个PCB分配1页空间，虽然用不了1页，剩下的会作为栈空间使用。

- 几个字段简单说明下：

  - ```self_kstack```：
      - 每个**线程**都有一个属于自己的栈空间，，这里面包括了内核栈和用户栈。

  - ```general_tag```：
    - 给每个**线程**分配一个tag，用于把线程“串”起来，放在某个队列中（如就绪队列、阻塞队列等）。
    - ```general_tag```就是把**线程**放在特定的队列中（如就绪队列、阻塞队列）。
  - ```all_list_tag```：
    - ```all_list_tag```把所用的**线程**串起来

- 以下字段，属于<font color="red">资源</font>，同一进程下的线程共享

    - ```pgdir```
      - 表示用户进程页表。
      - 每个进程有独立的页表，同一进程下的线程，共享该进程页表
    - ```userprog_vaddr```：
      - 用户进程的虚拟地址池。
      - 每个进程有独立的虚拟地址池，同一进程下的线程，共享
      - 跟```pgdir```配套使用
    - ```u_block_desc```：
      - 每个进程有DESC_CNT种规格的内存块mem_block，不同规格的内存块有不同的描述符u_block_desc来描述



### 2. 线程用到的栈

不管是在线程切换时保存上下文，还是中断发生时保存上下文，上下文信息都要保存在该进程的栈中，该栈也在PCB中。

#### 2.1 线程栈

**线程栈，是在线程切换时，保存的上下文。当该线程被调度，会从该栈中恢复上下文。**

线程栈设计的结构如下代码所示：

```c
struct thread_stack {
	uint32_t ebp;
	uint32_t ebx;
	uint32_t edi;
	uint32_t esi;

	/*
    	线程第一次执行时:
    		- eip指向待调用的函数kernel_thread
    		- 然后kernel_thread函数在从栈中取出function和func_arg，调用function(func_arg)
    	不是第一次执行：
    		- eip是指向switch_to的返回地址，也就是上一次被切换时的指令位置，这次接着执行
    */
	void (*eip) (thread_func* func, void* func_arg);
    
    /*下面字段，都是在kernel_thread函数中会被用到，所以只有第一次执行时才有用*/
	void (*unused_retaddr); // kernel_thread函数是被调函数，unused_retaddr充当主调函数的返回值
    						// 因为要想从栈中取参数，必须跨过主调函数的返回值
	thread_func* function;   // 在kernel_thread函数中，从栈中取出function
	void* func_arg;    // 在kernel_thread函数中，从栈中取出func_arg，将会执行funcion(func_arg)
};
```

线程栈的结构图如下：

![](https://gitee.com/imcgr/image_blog/raw/master/20210617141131.png)

- 关于该结构，为什么要这样设计？线程栈的作用是用来保存上下文，按理来说，只要保存当前线程执行到哪个地方就行了，也就是只需保存eip就可以了，为什么要保存这么多字段呢？
  - 关于```ebp```、```ebx```、```edi```、```esi```，是在ABI中规定的，这几个寄存器由主调函数来保护。
  - 关于```unused_retaddr```、```function```、```func_arg```，是在该线程第一次运行时才有用
    - 因为线程第一次运行（也就是构建PCB）时，线程栈中```eip```位置放的是```kernel_thread```函数的地址，然后在```kernel_thread```函数中再调用```function```。所以```function```和```func_arg```是作为参数，传入到```kernel_thread```函数中的。
    - 要想```kernel_thread```函数可以取到参数```function```和```func_arg```，只有把这两个参数放到栈中。
    - 在```kernel_thread```函数中，栈的情况如下：
    - <img src="https://gitee.com/imcgr/image_blog/raw/master/20210617144614.png" style="zoom: 80%;" />
    - <font color="red">所以我们是构建好栈的内容，保证在```kernel_thread```函数中，可以正确取到参数。</font>



####  2.2 中断栈

在发生中断处理程序是，CPU会进入0特权级，会用到0级栈。

如果发生中断处理程序前，不是在0级（比如用户程序在运行在3级），那么CPU的特权级会从3级切换到0级，并且会换栈，从3级栈切换到0级栈。

此时在切换栈时，需要保存上下文。这个切换栈的上下文就保存在中断栈intr_stack中。

中断栈的结构：

```c
struct intr_stack
{
    uint32_t vec_no; // kernel.S 宏VECTOR中push %1压入的中断号
    uint32_t edi;
    uint32_t esi;
    uint32_t ebp;
    uint32_t esp_dummy; // 虽然pushad把esp也压入,但esp是不断变化的,所以会被popad忽略
    uint32_t ebx;
    uint32_t edx;
    uint32_t ecx;
    uint32_t eax;
    uint32_t gs;
    uint32_t fs;
    uint32_t es;
    uint32_t ds;

    /* 以下由cpu从低特权级进入高特权级时压入 */
    uint32_t err_code; // err_code会被压入在eip之后
    void (*eip)(void);
    uint32_t cs;
    uint32_t eflags;
    void *esp;
    uint32_t ss;
};
```

上述的字段可以分为两类：

- 保存上下文（自定义）
  - 使用pushad指令，把很多寄存器压栈保存
- 保存中断上下文（CPU自动完成）
  - 当中断发生，CPU会自动压栈保存上下文

下图是CPU压栈的顺序：

![](https://gitee.com/imcgr/image_blog/raw/master/20210621201233.png)





关于中断栈和线程栈，在内存中的位置如下图：

![](https://gitee.com/imcgr/image_blog/raw/master/20210617164747.png)

- PCB中的self_stack字段，指向该PCB的最顶端，该地址作为栈底



### 3. 创建内核线程

所谓创建1个内核线程，就是构建好该线程需要的指令（代码块） + 上下文环境和资源，也就是**填充PCB**。

由于线程要执行的代码是放在线程栈intr_stack中的，所以**最关键的是构建线程栈intr_stack**。这样当该线程构建好了，被调度时，就可以从线程栈中找到要去执行的函数地址。



具体步骤如下：

- ```thread_start```创建线程
  - ```init_thread```初始化线程静态资源
  - ```thread_create```构建线程栈 和 执行流 ```kernel_thread```
    - 执行流是是```kernel_thread```，然后在```kernel_thread```函数中，调用自定义函数



#### 3.1 ```thread_start```

实现代码过程，自顶向下：

```c
/*
    Description:
        创建一个内核线程
    Parameters:
        name: char*。线程名称
        prio: int。线程优先级
        function: thread_func。该线程要执行的函数（代码块、指令）
        func_arg: void*。function函数需要的参数。function(func_arg)
    Return:
        thread: struct task_struct*。生成的内核线程的pcb地址
    Details:
        - 申请内存，存放PCB
        - 初始化PCB的静态属性，比如pid，priority等
        - 让该线程可以执行指定的函数，建立线程和函数的连接
        - 加入就绪队列中，等待被操作系统调度执行
        - 加入全部线程队列
*/
struct task_struct *thread_start(char *name, int prio, thread_func function, void *func_arg)
{
    // 1. 申请内存，存放PCB
    struct task_struct *thread = get_kernel_pages(1);
    // 2. 初始化PCB的静态属性，比如pid，priority等
    init_thread(thread, name, prio);
    // 3. 让该线程可以执行指定的函数，建立线程和函数的连接
    thread_create(thread, function, func_arg);
    // 4. 加入就绪队列中，等待被操作系统调度执行
    list_append(&thread_ready_list, &thread->general_tag);

    // 5. 加入全部线程队列
    list_append(&thread_all_list, &thread->all_list_tag);

    return thread;
}
```

创建内核线程，也就是这几步骤：

- 申请内存，存放PCB。```get_kernel_pages(1)```。
- 初始化PCB的静态属性，比如pid，priority等。```init_thread()```。
- 让该线程可以执行指定的函数，建立线程和函数的连接。```thread_create```。
- 加入就绪队列中，等待被操作系统调度执行。
- 加入全部线程队列。



#### 3.2 ```init_thread```

初始化PCB静态属性，```init_thread()```函数：

```c
/*
    Description:
        初始化线程的静态属性
    Parameters:
        pthread: struct task_struct*。要初始化的线程
        name: char*。该线程名字
        prio: int。该线程的优先级。
*/
void init_thread(struct task_struct *pthread, char *name, int prio)
{
    memset(pthread, 0, sizeof(*pthread));
    pthread->pid = allocate_pid();
    strcpy(pthread->name, name);

    if (pthread == main_thread)
    {
        /* 由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */
        pthread->status = TASK_RUNNING;
    }
    else
    {
        pthread->status = TASK_READY;
    }

    /* self_kstack在该线程的PCB顶部 */
    pthread->self_kstack = (uint32_t *)((uint32_t)pthread + PG_SIZE);
    pthread->priority = prio;
    pthread->ticks = prio;
    pthread->elapsed_ticks = 0;
    // 这里页表为空，因为线程没有页表
    pthread->pgdir = NULL;
    pthread->parent_pid = -1;          // -1表示没有父进程
    pthread->stack_magic = 0x19870916; // 自定义的魔数
}
```

- 就是填充PCB的字段
  - 比如申请pid
  - 给线程名称、线程状态、栈地址、优先级等属性赋值

- 设置了一个线程的栈地址，就是当前PCB的最顶端，如下图：
- <img src="https://gitee.com/imcgr/image_blog/raw/master/20210617164747.png" style="zoom: 80%; " align="left" />
- 

#### 3.3 ```thread_create```

初始化该线程要执行的代码，以及上下文环境```thread_create```：

```c
/*
    Description:
        初始化pthread线程，需要执行的代码，以及上下文环境（寄存器、栈）。
    Parameters:
        pthread: struct task_struct*。要操作的线程
        function: 该线程要执行的代码地址
        func_arg: function对应的参数。function(func_arg)
    Details:
        - 预留中断栈空间
        - 预留线程栈空间
        - 设置线程栈的内容（在执行线程切换时，会操作该线程栈）
            - 执行的函数地址function放入栈中的function位置，该地址从栈中弹出可以执行
            - 栈中保存function函数需要的参数
            - 栈中其他寄存器的镜像，没用，都清0
*/
void thread_create(struct task_struct *pthread, thread_func function, void *func_arg)
{
    /* 先预留中断使用栈的空间,可见thread.h中定义的结构 */
    pthread->self_kstack -= sizeof(struct intr_stack);

    /* 再留出线程栈空间,可见thread.h中定义 */
    pthread->self_kstack -= sizeof(struct thread_stack);
    // 设置线程栈的内容，把要执行的函数地址function放入栈中的function位置
    struct thread_stack *kthread_stack = (struct thread_stack *)pthread->self_kstack;
    
    kthread_stack->eip = kernel_thread;
    
    kthread_stack->function = function;
    kthread_stack->func_arg = func_arg;
    // 栈中的寄存器镜像，都清0 
    kthread_stack->ebp = kthread_stack->ebx = kthread_stack->esi = kthread_stack->edi = 0;
}
```

- 这里主要是搭建线程和自定义函数之间的联系，这样该线程运行时，就可以执行该函数
- 主要方式是，把要执行的函数相关信息，放入到该线程中的线程栈thread_stack中
  - 然后等待被调度，被调度后就可以执行函数的代码了
- <font color="red">```kthread_stack->eip```才是弹栈时，将要被执行的函数地址，也就是```kernel_thread```函数。</font>
- <font color="red">然后```kthread_stack->function```和```kthread_stack->func_arg```， 只是作为```kthread_stack->eip```指向的函数（```kernel_thread```函数）所需要的参数，也就是<b>kernel_thread函数里面执行function(func_arg)</b></font>



#### 3.4 ```kernel_thread```

在创建内核线程时，线程栈中的eip位置，存放的是```kernel_thread```函数的地址，也就是，当线程栈中的eip弹出，就会去执行eip指向的函数，也就是会执行```kernel_thread```函数。

```c
/* 由kernel_thread去执行function(func_arg) */
static void kernel_thread(thread_func *function, void *func_arg)
{
    /* 执行function前要开中断,避免后面的时钟中断被屏蔽,而无法调度其它线程 */
    intr_enable();
    function(func_arg);
}
```

- 在```kernel_thread```函数中取出参数```function```和```func_arg```，然后执行```function(func_arg)```
- 参数是从栈中取出来的，所以我们要构建好栈的内容。也就是上面构建好的线程栈，如下图：
  - <img src="https://gitee.com/imcgr/image_blog/raw/master/20210617144614.png" style="zoom: 80%;" />
- 提问：为什么要在线程栈中的```eip```放```kernel_thread```的地址呢？为什么不直接放自定义函数的地址呢？
  - 仅仅是为了开中断吗？



#### 3.5 代码调用图

代码调用图如下：

（图片太大？点击链接查看：<a href="https://gitee.com/imcgr/image_blog/raw/master/20210617152101.png">代码调用图</a>）

![代码调用图](https://gitee.com/imcgr/image_blog/raw/master/20210617152101.png)



### 4. 线程切换

切换线程，就是要保存当前cur线程的上下文，然后从就绪队列中获取到要执行的下一个线程next，然后从next的线程栈中恢复next线程的上下文，然后执行next。

实现方式如下：

- 获取当前线程PCB
- 获取下一个线程PCB
  - 从就绪队列中获取
- 修改当前线程的状态和保存上下文
  - 如果是因为时间片到了，就给当前线程重新赋值时间片，并且修改线程状态，由RUNNING到READY
  - 保存当前线程上下文到当前线程的线程栈intr_stack中
- 修改下一个线程的状态和恢复上下文
  - 把下一个线程的状态该为RUNNING，并且激活该线程所在进程的页目录表
  - 从线程栈intr_stack中恢复当前线程的上下文



#### 4.1 获取当前线程和下一个线程的PCB

```c
/*
    Description:
        切换线程，重新进行调度，如果没有线程可以调度，就运行idle线程
    Details:
        实现原理：
            获取当前线程cur，从就绪队列中获取下一个要执行的线程next，然后切换。
        使用场景：
            - 该函数一般当时间片用完由时钟中断处理函数调用
            - 或者阻塞时，需要放开时间片，调用该函数切换线程
*/
void schedule()
{
    ASSERT(intr_get_status() == INTR_OFF);

    struct task_struct *cur = running_thread();
    if (cur->status == TASK_RUNNING)
    { // 若此线程只是cpu时间片到了,将其加入到就绪队列尾
        ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
        list_append(&thread_ready_list, &cur->general_tag);
        cur->ticks = cur->priority; // 重新将当前线程的ticks再重置为其priority;
        cur->status = TASK_READY;
    }
    else
    {
        /* 若此线程需要某事件发生后才能继续上cpu运行,
      不需要将其加入队列,因为当前线程不在就绪队列中。*/
    }

    /* 如果就绪队列中没有可运行的任务,就唤醒idle */
    if (list_empty(&thread_ready_list))
    {
        thread_unblock(idle_thread);
    }

    ASSERT(!list_empty(&thread_ready_list));
    thread_tag = NULL; // thread_tag清空
                       /* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */
    thread_tag = list_pop(&thread_ready_list);
    struct task_struct *next = elem2entry(struct task_struct, general_tag, thread_tag);
    next->status = TASK_RUNNING;

    /* 击活任务页表等 */
    process_activate(next);
    switch_to(cur, next);
}
```

- 切换进程，逻辑上，就是获取当前线程cur和将要执行的线程next，然后从cur切换到next。
- 该```schedule```函数，调用了```switch_to```函数，```switch_to```才是保存和恢复上下文的地方。



#### 4.2 保存当前线程的上下文和恢复欲执行线程的上下文

保存和恢复上下文，```switch_to```函数：

```assembly
[bits 32]
section .text
global switch_to
switch_to:
   ;栈中此处是返回地址	       
   push esi
   push edi
   push ebx
   push ebp

   mov eax, [esp + 20]		 ; 得到栈中的参数cur, cur = [esp+20]
   mov [eax], esp            ; 保存栈顶指针esp到cur的self_kstack字段,
				 			 ; self_kstack在task_struct中的偏移为0,
				 			 ; 所以直接往thread开头处存4字节便可。
				 			 
;------------------  以上是备份当前线程的环境，下面是恢复下一个线程的环境  ----------------
   mov eax, [esp + 24]		 ; 得到栈中的参数next, next = [esp+24]
   mov esp, [eax]		 	 ; pcb的第一个成员是self_kstack成员,用来记录0级栈顶指针,
				 			 ; 用来上cpu时恢复0级栈,0级栈中保存了进程或线程所有信息,包括3级栈指针
   pop ebp
   pop ebx
   pop edi
   pop esi
   ret				 ; 返回到上面switch_to下面的那句注释的返回地址,
				 	 ; 未由中断进入,第一次执行时会返回到kernel_thread
```

- 该函数，执行了两个操作：
  - 保存**当前**线程的**上下文**，到**当前的线程栈**中
  - 从**下一个线程的中断栈**，恢复**下一个**线程的**上下文**



- 在执行```switch_to```函数时，栈的操作比较复杂，这里只看看PCB中栈的局部情况：

![](https://gitee.com/imcgr/image_blog/raw/master/20210617181858.png)

- 上述代码，一顿操作，主要就是在**保存**cur的**栈顶指针**到cur的PCB中，和从next的PCB中**恢复**next的**栈顶指针**。
- 上述的```switch_to```操作了cur和next两个任务的栈：
  - 把当前的esp保存到cur的PCB的```self_kstack```字段中，保存上下文
    - 访问[esp + 20]得到cur的```cur->self_kstack```的地址（```cur->self_kstack```就在PCB的底部）
    - 直接把esp给```cur->self_kstack```赋值，那么就保存了当前的esp到cur的PCB中。
  - 把next的PCB的```self_kstack```字段，取出来，放到esp寄存器中，恢复上下文
    - 访问[esp + 24]得到```next->self_kstack```的地址
    - 把```next->self_kstack```的内容取出来，得到next的栈顶指针
- 每个线程的ip寄存器怎么没有保存？因为**eip的值是CPU自动保存和恢复的**
  - 因为在进入```switch_to```时保存了cur的eip到cur的栈中
  - 在执行```switch_to```的```ret```指令，将next栈中的eip恢复了



### 5. 一个内核线程从创建到执行到被切换

上面只是局部地看了一下，切换任务时的压栈和出栈情况。在切换任务时，如果涉及到特权级的变化，那么比较麻烦了。

下面分析下，一个内核线程A，从创建出来，到被调度执行的过程。



基本过程应该是这样的：

- 创建内核线程A（构建PCB、中断栈、线程栈）
- 进入时钟中断处理函数，然后调用```schedule```，```schedule```调用```switch_to```切换到线程A
- 线程A的自定义函数代码被执行
- 线程A的执行过程中，发生时钟中断，A被换下



#### 5.1 创建内核线程A

创建内核线程上面已经写了，这是代码调用图：（图片太大？点击链接查看：<a href="https://gitee.com/imcgr/image_blog/raw/master/20210617152101.png">代码调用图</a>）![代码调用图](https://gitee.com/imcgr/image_blog/raw/master/20210617152101.png)

主要是要构建A的线程栈，构建出来的效果如下图：

![](https://gitee.com/imcgr/image_blog/raw/master/20210617185317.png)

#### 5.2 切换任务（从cur切换到任务A）

然后就是进入时钟中断处理函数，准备重新调度了。然后时钟中断处理函数会调用```schedule```函数，把线程A从就绪队列中取出来，然后进入```switch_to```函数，然后开始恢复线程A的上下文：

```assembly
switch_to:
	;.......保存cur的上下文，省略
				
;------------------  以上是备份当前线程的环境，下面是恢复下一个线程的环境  ----------------
   mov eax, [esp + 24]	; 取出A线程的PCB
   mov esp, [eax]	; 取出PCB的self_kstack指针，回复esp栈顶指针
   
   pop ebp
   pop ebx
   pop edi
   pop esi
   ret
```

- 如上面A线程的的线程栈图，经过```switch_to```的弹栈和```ret```指令，会把线程栈中的eip字段，也就是```kernel_thread```函数的地址作为eip寄存器的值，也就是PC指针指向了```kernel_thread```函数
- 所以执行```switch_to```的```ret```指令后，就会执行```kernel_thread```函数。

#### 5.3 线程A的自定义函数的代码被执行

进入```kernel_thread```函数:

```c
/* 由kernel_thread去执行function(func_arg) */
static void kernel_thread(thread_func *function, void *func_arg)
{
    /* 执行function前要开中断,避免后面的时钟中断被屏蔽,而无法调度其它线程 */
    intr_enable();
    function(func_arg);
}
```

此时线程A的线程栈，内容如下：

![线程A的线程栈](https://gitee.com/imcgr/image_blog/raw/master/20210617190003.png)



```kernel_thread```需要两个参数：```function```和```func_arg```，理所当然从栈里面取（但是栈顶指针并没有变），所以从上图的线程栈中取出自定义函数```function```的地址、自定义函数的参数```func_arg```的地址。

然后执行```function(func_arg)```。



<font color="red">栈空间是由主调函数来回收的，也就是需要调用```kernel_thread```的函数来回收栈空间，但是并没有函数调用```kernel_thread```函数，所以此时图中线程栈中的```unused_retaddr```、```function```、```func_arg```三个字段（图中换色部分），**不会被回收的**。</font>

<font color="red"><b>这也就是为什么，在线程栈的结构体中，```unused_retaddr```、```function```、```func_arg```这三个字段，只有在第一次被CPU调度时，才有用。</b></font>



#### 5.4 线程A被换走

假设在执行过程中，时间片用完了，发生时钟中断，线程A要被换下来。

同样发生时钟中断，执行中断处理程序，执行```schedule```函数，执行```switch_to```函数：

```assembly
switch_to:
   ;栈中此处是返回地址	       
   push esi
   push edi
   push ebx
   push ebp

   mov eax, [esp + 20]
   mov [eax], esp

;------------------  以上是备份当前线程的环境，下面是恢复下一个线程的环境  ----------------
   mov eax, [esp + 24]	
   mov esp, [eax]	
				 
   pop ebp
   pop ebx
   pop edi
   pop esi
   ret	
```

在```schedule```中调用```switch_to```，再次把将要执行的线程next的pcb地址入栈，把当前线程A的PCB地址入栈，然后把```switch_to```的下一条指令入栈。

然后继续保存上下文、恢复上下文，以此循环。。。

### 三、总结

这一节，主要创建内核线程，由于是内核线程，所以没有设计到特权级的变化，所以稍微简单点。

**内核线程由创建到运行，关键是构建好PCB和线程栈，然后就是等待被CPU调度，这时，CPU就会从线程栈中恢复上下文，就会去执行自定义的函数了**。















