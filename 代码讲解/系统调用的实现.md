[toc]

## 系统调用的封装

说到系统调用，我们都知道，操作系统把一些核心、底层、需要暴露给用户程序的操作（比如输入输出、读写硬盘等），封装成系统调用，然后用户进程通过发起系统调用，来实现一些“秘密”操作。

在当时学习系统调用时，不禁有以下疑问：

- 为什么需要系统调用？
  - 为什么不让用户进程直接操作这些功能呢？比如硬盘、输入输出？
- 系统调用和普通函数调用有什么区别？
  - 用户程序调用自己的函数，和调用系统调用有何区别？
- 如何实现的系统调用？
  - 系统调用是什么样的形式？封装成函数？
  - 比如C程序直接调用系统调用的函数，那么在编译期，编译器不会报undefined reference吗？



要说清楚以上几个问题，不得不讲述几个概念，以及关于CPU的设定。

### 一、特权级

#### 1. 为什么需要特权级

- 实模式
  - 前面说过，早期的CPU是16位实模式的，操作系统也是16位的（比如DOS系统）
  - 操作系统和用户进程处于相同地位，用户进程甚至可以修改操作系统的代码，十分不安全
- 保护模式
  - 后来出现了保护模式，有了4种特权级0、1、2、3级，0级权限最大，3级权限最小。<font color="red">低特权级的代码不能访问高特权级的代码和数据</font>
  - 对于Linux操作系统只使用了2级，<font color="red">系统内核处于0级，用户程序处于3级</font>
    - 这让操作系统处于更高的地位，用户进程无法修改操作系统“保护”起来的数据
- 操作系统特权级和用户特权级
  - 所以操作系统把一些关键操作，比如输入输出、操作硬盘、操作系统自身代码和数据，放在0特权级中，用户进程处于3特权级是无法访问这些操作的
  - 但是用户进程也需要这些操作啊，如何让这些0特权级的操作让用户进程可以访问呢？

#### 2. CPL、DPL、RPL

关于特权级的描述，这里有3个名词：

- CPL: Current Privilege Level
  - **CPL表示<font color="red">CPU</font>当前的特权级**
  - 比如CPU在执行用户程序，用户程序代码特权级是3级。也就是CPL = 3
  - CPU在执行系统内核代码，内核代码特权级时0级，也就是CPL = 0
- DPL: Descriptor Privilege Level
  - **DPL表示<font color="red">欲访问的目标段</font>的特权级**
  - 比如CPU有一条指令，要访问内核数据（特权级为0），也就是DPL = 0。如果是想要访问用户数据，那么DPL = 3。
  - 比如CPU将要使用jmp指令，跳转到内核代码，也就是DPL = 0。如果是要跳转执行用户代码，那么DPL = 3
- RPL: Request Privilege Level（可以暂时忽略，看了后面才知道）
  - **RPL表示<font color="red">请求的指令</font>的特权级**
  - 比如当前处于**内核**进程（CPL=0），将要访问内核数据（DPL = 0）,请求者就是内核指令，RPL = 0
  - 比如当前是**用户**进程（CPL=0），要访问内核程序（DPL = 0），请求这就是内核指令，RPL = 0
  - 看到这里，你可能会说RPL 不是和CPL一样吗？其实不然。
    - 比如**当前是用户程序**，RPL  = CPL  = 3。
    - 然后发**起了系统调用**（中断门），开始执行内核代码，CPL = 0。
    - 但是发起中断时，会把**原先的CPL（也是RPL）压入中断栈保存**，也就是RPL此时在中断栈中，依然为3.



也就是，处于3特权级下的用户进程，如何 越级 访问 处于0特权级的代码和数据？关键在于要提高CPL。

### 二、中断门

CPU提供了一种方式来提高CPL，就是“门结构”。通过调用“门”，就可以提高特权级。

调用了“门结构”后，就可以把CPL提升到0特权级。

Linux系统只使用了中断门，这里也只讲中断门。**Linux中系统调用也是对中断的封装**。

#### 1. 中断门描述符的结构

什么是中断门描述符？就是描述一个中断的，而中断，最关键的就是中断处理程序。所以中断门描述符，主要用来描述中断处理程序。

中断处理程序，是一段代码，不是已经有代码段描述符来描述了吗？为什么还需要中断门描述符？



这是因为，处于0级的代码段，无法被3级的访问，而中断门描述符，给了3级程序的一个机会。

也就是3特权级进程，通过中断门描述符，有机会 执行0级的中断处理程序。





中断门描述符结构如下：

![中断门结构](https://gitee.com/imcgr/image_blog/raw/master/20210623130345.png)

注意下面几个字段：

- 中断处理程序目标代码段 段描述符 选择子
- 中断处理程序目标代码段 内 偏移量

上述2个字段，就可以定位到一段代码段，也就是中断处理程序。



剩下的比较零散的字段，比如P、DPL、S、TYPE，比较容易：

- P表示该中断处理程序是否存在
- <font color="red"><b>DPL，表示是否有资格，调用该中断门描述符</b></font>
  - 中断门描述符，给了CPU一个提升CPL的机会。
  - 但是如果，CPL小于中断门描述符的DPL，也就是数值上CPL > DPL，那么就没有资格调用该中断门描述符，也就是没有资格提升CPL。
- 剩下的字段比较固定，不讲了



#### 2. 调用中断门描述符

一个中断门描述符描述一个中断，很多中断就有很多中断门描述符，组成中断门描述符表（IDT）。

如何调用中断门描述符呢？

- 使用中断指令```int```。
- 比如Linux系统中发起系统调用，使用指令```int 0x80```。
  - 这就是因为Linux的系统调用，使用的是80号中断



那么加上中断门描述符后，执行中断处理程序目标代码段的流程是：

- 调用中断门描述符（使用```int```指令来调用）（假如“合格”的话，也就是RPL <= 中断门描述符的DPL）
- 根据中断门描述符得到， **中断处理程序目标代码段 的 选择子和偏移量**
- 根据选择子，访问全局描述符表GDT，得到**目标代码段的基址**。然后**基址加上偏移量**，**得到目标代码段完整的地址**（虚拟地址）。
- 根据完整的地址，访问中断处理程序的目**标代码段**。

简单来说，加上中断门描述符后：

- 原本是直接通过```选择子：偏移量```来访问目标代码段
- 现在需要先调用中断门描述符，得到```选择子：偏移量```再去访问代码段



<font color="red"><b>总结来说，中断门描述符相当于一个门槛（中断门描述符的DPL），如果可以跨过这个门槛（CPL <= 中断门描述符的DPL），那么就可以CPL提升到0特权级</b></font>



### 三、系统调用实现原理

Linux的系统调用就是通过调用中断门来实现的。

那么系统调用和中断有什么区别？

- 系统调用属于中断，它们都有中断门描述符来描述。
- **<font color="red">系统调用的中断门描述符“门槛”比较低，可以让用户进程调用。</font>**

也就是，只要把中断门描述符的DPL设置为3，那么用户进程就可以“跨过门槛”，那么就可以执行中断处理了程序，CPL就可以提升了。



### 四、系统调用的代码实现

下面就来封装一个系统调用函数```getpid()```，功能是获取当前线程的pid号。pid是放在进程的PCB中的，但是进程的PCB是放在内核的数据段中，用户进程无法直接访问。所以必须通过系统调用来访问。



这里仿造Linux，系统调用使用0x80号中断。获取pid的子中断号为1。



在之前学习硬件的中断（<a href="#">中断的注册和触发</a>（<font color="red">**此链接未填充**</font>）），注册中断处理程序，然后由时钟来触发时钟中断处理程序。主要就是如下几个步骤：

- 构建中断描述符表
- 构建中断处理函数
- 建立中断描述符和中断处理函数的联系

中断描述符表之前已经建好了，只需要添加第0x80项即可。

中断处理函数，就是获取当前任务的pid，只需要执行```running_thread()->pid```就可以获取到。

建立中断描述符表和中断处理函数的联系，也就是把获取pid这个函数地址，添加到中断描述符中。



而我们，要把上述三个操作封装成一种更加通用的形式，也就是封装成系统调用，所以还有一步：

- 封装成系统调用



#### 1. 构建中断描述符表

在中断描述符表中添加一个中断门描述符，并且该中断门描述符下标是0x80：

```c
/*初始化中断描述符表*/
static void idt_desc_init(void)
{
    for (int i = 0; i < IDT_DESC_CNT; i++)
    {
        make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]);
    }
    
   	// 设置下标为0x80号的中断门描述符
    // 设置该中断门描述符的DPL = 3, 让用户进程有资格可以“跨过门槛”
    // 设置该中断门描述符的中断处理程序为syscall_handler
    make_idt_desc(&idt[0x80], IDT_DESC_ATTR_DPL3, syscall_handler);
    put_str("idt_desc_init done\n");
}
```

- 上述代码，两个关键点：
  - 设置中断门描述符的位置，放在中断门描述符表IDT的0x80下标处
  - 设置中断门描述符的中断处理函数为 syscall_handler
    - 因为所有的系统调用，共用1个中断门描述符，所以此时中断门描述符对应的中断处理函数不是1个，而是多个
    - 不同的系统调用，使用子调用号，放在eax寄存器中来区分



#### 2. 构建中断处理函数

上面的中断处理函数，也就是```syscall_handler```，用来处理所有的系统调用，还需要使用子调用号放在eax中，来执行具体的系统调用。

```assembly
;;;;;;;;;;;;;;;;   0x80号中断的中断处理程序 syscall_handler   ;;;;;;;;;;;;;;;;
[bits 32]
extern syscall_table
section .text
global syscall_handler
syscall_handler:
   ;1 保存上下文环境
   push 0			    ; 压入0, 使栈中格式统一

   push ds
   push es
   push fs
   push gs
   pushad			    ; PUSHAD指令压入32位寄存器，其入栈顺序是:
				    ; EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI 
				 
   push 0x80			    ; 此位置压入0x80也是为了保持统一的栈格式

;2 为系统调用子功能传入参数
   push edx			    ; 系统调用中第3个参数
   push ecx			    ; 系统调用中第2个参数
   push ebx			    ; 系统调用中第1个参数

;3 调用子功能处理函数
   call [syscall_table + eax*4]	    ; 编译器会在栈中根据C函数声明匹配正确数量的参数
   add esp, 12			    ; 跨过上面的三个参数

;4 将call调用后的返回值存入待当前内核栈中eax的位置
   mov [esp + 8*4], eax	
   jmp intr_exit		    ; intr_exit返回,恢复上下文
```

- 这个```syscall_handler```是调用中断门描述符，真正直接执行的函数（子程序）
- 针对不同的具体的系统调用，根据eax中的子系统调用号来决定
  - 然后根据子系统调用号，调用```syscall_table```中的不同的系统调用
  - ```syscall_table```放的是具体的中断处理函数的地址

- 这个```syscall_handler```也算是中断处理函数的入口，执行完毕后，通过这个函数的```jmp intr_exit```的```iret```指令来退出中断处理程序，恢复原先的特权级。

- <font color="red">当CPU开始执行```syscall_handler```，就已经处于0特权级了。</font>



#### 3. 构建具体的中断处理函数

在上一步中，实现的```syscall_handler```只能算是中断处理函数的入口，根据不同的子调用号，来调用具体的中断处理函数。所以真正的中断处理函数，如下所示：

```c
#define syscall_nr 32 // 一共支持32个系统调用
typedef void* syscall;
syscall syscall_table[syscall_nr]; // syscall_table每一项，放的是函数地址

// 获取当前进程的pid
uint32_t sys_getpid(void) {
   return running_thread()->pid;
}

// 把sys_getpid函数的地址给syscall_table
syscall_table[SYS_GETPID]  = sys_getpid; // SYS_GETPID是常量0
```

- ```syscall_table[syscall_nr]```是放的子系统调用数组
  - 该数组的每一项都是一个函数的代码
  - 数组项保存的函数，就是触发系统调用会执行的内容



#### 4. 封装成系统调用

<font color="red"><b>有了上述的3个操作，用户进程已经可以使用```int 0x80```来发起系统调用了</b></font>

但是，有没有更加简便的方法，把系统调用封装成用户可以调用的函数呢？

当然是有的，发起系统调用，也是对```int 0x80```指令的封装而已。



这里同样模仿Linux的实现，封装了四种通用的系统调用：

- 无参数的系统调用
- 1个参数的系统调用
- 2个参数的系统调用
- 3个参数的系统调用

统一使用宏来实现，对指令```int 0x80```的封装：

```c
/* 无参数的系统调用 */
#define _syscall0(NUMBER) ({				       \
   int retval;					               \
   asm volatile (					       \
   "int $0x80"						       \
   : "=a" (retval)					       \
   : "a" (NUMBER)					       \
   : "memory"						       \
   );							       \
   retval;						       \
})

/* 一个参数的系统调用 */
#define _syscall1(NUMBER, ARG1) ({			       \
   int retval;					               \
   asm volatile (					       \
   "int $0x80"						       \
   : "=a" (retval)					       \
   : "a" (NUMBER), "b" (ARG1)				       \
   : "memory"						       \
   );							       \
   retval;						       \
})

/* 两个参数的系统调用 */
#define _syscall2(NUMBER, ARG1, ARG2) ({		       \
   int retval;						       \
   asm volatile (					       \
   "int $0x80"						       \
   : "=a" (retval)					       \
   : "a" (NUMBER), "b" (ARG1), "c" (ARG2)		       \
   : "memory"						       \
   );							       \
   retval;						       \
})

/* 三个参数的系统调用 */
#define _syscall3(NUMBER, ARG1, ARG2, ARG3) ({		       \
   int retval;						       \
   asm volatile (					       \
      "int $0x80"					       \
      : "=a" (retval)					       \
      : "a" (NUMBER), "b" (ARG1), "c" (ARG2), "d" (ARG3)       \
      : "memory"					       \
   );							       \
   retval;						       \
})
```

- 上述是通用的系统调用，本质上就是对```int 0x80```的封装
- 按照参数的个数，来分成了以上4类



那么最终封装好的获取当前任务pid的函数是：

```c
/* 返回当前任务pid */
uint32_t getpid() {
   return _syscall0(SYS_GETPID);
}
```

- 所以只要用户进程调用```getpid()```函数即可。



### 五、系统调用发生的过程总结

总结一下上述调用```getpid```函数的过程：

- 调用```getpid()```，发起系统调用```__syscall0(SYS_GETPID)```，传递了子中断号```SYS_GETPID```
- 在```__syscall0(SYS_GETPID)```内部本质上调用```int 0x80```指令，另外给```eax```寄存器赋值```SYS_GETPID```也就是子中断号
- 调用```int 0x80```后，就会根据IDTR寄存器，找到IDT，然后在IDT中查找0x80号中断描述符
- 根据0x80号中断描述符，比较中断描述符的DPL和CPL（这里DPL = 3, CPL = 3），通过，那么就会切换特权级（会保存上下文到中断栈中）。
- 根据中断描述符的中断处理程序 选择子 + 偏移量，0x80号中断描述符注册的中断处理函数是```syscall_handler```
- 执行```syscall_handler```，其中调用```call [syscall_table + eax*4]```，也就是调用```syscall_table```下标为```eax```项的函数。
- ```syscall_table```是具体的系统调用程序，子系统调用号是```syscall_table```的下标
- 最终会调用```syscall_table[i]```项，这就是系统调用执行的最终函数。
- 该函数返回，回到```syscall_handler```中，然后执行```intr_exit```，借用```iret```指令，从中断处理函数中退出，恢复中断栈的上下文，回到3特权级。



代码调用图如下所示：

![系统调用getpid的封装过程代码调用](https://gitee.com/imcgr/image_blog/raw/master/20210623211202.png)

- 上图里层虚线框的内容都是固定的，不用修改的
- 在封装新的系统调用时，只需要改动外层虚线框的三段代码即可。











