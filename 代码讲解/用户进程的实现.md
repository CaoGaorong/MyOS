## 用户进程的实现

### 一、进程

先说说进程，程序就是很多指令，这些指令从硬盘中加载到内存，指挥CPU去干事情。也就是执行流，单条执行流就是一个线程。

指令可以看做是动作，但是光有动作肯定不行，还要有资源，比如内存保存数据。

这也就是为什么常说：进程  = 线程 + 资源

### 二、进程的特权级

特权级的分类：

- x86的CPU有多种特权级，分为了0级、1级、2级、3级。

- 0级最高，3级最低。Linux系统只用到了两级，内核态在0级，用户态在3级。低特权级的进程/线程不能访问高特权级的资源。
  - 如果低特权级的进程访问高特权级的资源，CPU就会发生异常。
  - 对特权级的判断，是CPU自动完成



用户进程的特权级：

- 用户进程运行在3级中，也只能访问特权级为3级的资源。
- 如果用户进程想访问高特权级的资源，必须发起系统调用，否则CPU会报异常。
  - 操作系统把一些对硬件的操作比如在屏幕中打印、获取键盘输入、操作网卡/硬盘等都设置了为0级，把一些重要的资源，比如自身的指令、数据都设置为0级，让普通用户程序无法访问。
  - 操作系统把一些基础的操作，封装成了系统调用给用户程序使用。

- 当用户进程发起系统调用，CPU进入0级，使用的栈也要切换到0级栈

### 三、实现用户进程要实现哪些东西

<font color="dodgerblue"><b>由于已经实现了内核线程，所以再实现用户进程简单很多，有的功能在 实现内核线程 部分，已经实现了，比如切换线程</b></font>。

要实现用户进程，首先要让用户进程可以跑起来，有以下问题：

- 用户进程的结构？
- 用户进程的虚拟地址的实现？
- 用户进程进入内核态，如何找到0级栈？栈如何切换？



其中对关键的就是：

- <font color="red">内核态和用户态互相切换</font>

### 四、实现用户进程

实现进程，就是实现 执行流+资源：

- 执行流就是我们要这个用户进程干的事情，也就是我们自定义的函数。
- 资源，就是用户进程用到的内存空间，比如页表、栈



所以在这里，实现进程，仅仅比实现之前的内核线程多了两样东西：

- 页表，每个进程都单独的页表
- 虚拟地址池。每个进程有独立的4GB虚拟地址，所以必须有独立的虚拟地址池。

出了上述2样东西，其他都是一样的。



另外，需要关注的就是特权级的变化。<font color="red">原本CPU在执行操作的代码，处于0级。那么CPU去执行用户程序代码，如何变为3级呢？</font>

#### 1. PCB

这里线程和进程都是相同的PCB，和之前实现内核线程一样的。

只不过内核线程的PCB的```pgdir```也就是页表字段和```userpro_vaddr```字段，没有赋值。

而用户进程的PCB的```pgdir```和```userpro_vaddr```字段，是指向的用户进程的页表和虚拟地址池。



PCB的结构如下：

```c
/* 进程或线程的pcb,程序控制块 */
struct task_struct
{
    uint32_t *self_kstack; // 各内核线程都用自己的内核栈
    pid_t pid;
    enum task_status status;
    char name[TASK_NAME_LEN];
    uint8_t priority;
    uint8_t ticks; // 每次在处理器上执行的时间嘀嗒数
    uint32_t elapsed_ticks; // 此任务自上cpu运行后至今占用了多少cpu嘀嗒数, 也就是此任务执行了多久
    struct list_elem general_tag; // general_tag的作用是用于线程在一般的队列中的结点
    struct list_elem all_list_tag; // all_list_tag的作用是用于线程队列thread_all_list中的结点
    uint32_t *pgdir;                              // 进程自己页表的虚拟地址
    struct virtual_addr userprog_vaddr;           // 用户进程的虚拟地址
    struct mem_block_desc u_block_desc[DESC_CNT]; // 用户进程内存块描述符
    pid_t parent_pid;                             // 父进程pid
    int8_t exit_status;                           // 进程结束时自己调用exit传入的参数
    uint32_t stack_magic;                         // 用这串数字做栈的边界标记,用于检测栈的溢出
};
```



#### 2. 创建用户进程

**创建进程，和创建内核线程一样，说白了，就是填充PCB。只不过用户进程涉及到特权级，更复杂一点。**



创建过程如下所示（自顶向下）：

- ```process_execute```创建用户进程
  - ```init_thread``` 初始化线程的静态资源
  - ```create_user_vaddr_bitmap``` 创建用户进程的虚拟地址池
  - ```thread_create``` 构建用户进程的 线程栈 和执行流```start_process```
    - 在```start_process```函数中，构建中断栈，以及自定义函数（执行流）
  - ```create_page_dir```构建页表



##### 2.1 ```process_execute```

```c
/*
    Description:
        创建一个用户进程
    Parameters:
        filename: void*。进程的执行流。也就是自定义的用户线程函数。
        name: char*。进程名称
    Details:
        - 申请1页内存，放用户进程的PCB
        - 初始化PCB的静态属性，比如pid，priority等
        - 设置用户进程PCB的虚拟地址池 create_user_vaddr_bitmap
        - 设置用户进程中要执行的代码段，建立用户进程和自定义函数的连接
        - 设置用户进程的页表
        - 把用户线程加入就绪队列
        - 把用户线程加入全部线程队列
*/
void process_execute(void *filename, char *name)
{
    // 1. 申请1页内存，存放进程PCB
    struct task_struct *thread = get_kernel_pages(1);
    // 2. 初始化PCB的静态属性，比如pid，priority等
    init_thread(thread, name, default_prio);
    // 3. 设置用户进程PCB的虚拟地址池
    create_user_vaddr_bitmap(thread);
    // 4. 设置用户进程中要执行的代码段，建立用户进程和自定义函数的连接
    thread_create(thread, start_process, filename);
    // 5. 申请用户进程的页表
    thread->pgdir = create_page_dir();

    enum intr_status old_status = intr_disable();
    // 6. 加入就绪队列
    list_append(&thread_ready_list, &thread->general_tag);

    // 7. 加入全部队列
    list_append(&thread_all_list, &thread->all_list_tag);
    intr_set_status(old_status);
}
```

上述代码创建一个用户线程：

- 申请内存，存放PCB。```get_kernel_pages(1)```
- 初始化PCB的静态属性，比如pid，priority等。```init_thread()```。
  - 可以认为线程是进程的一部分，所以这里使用了```init_thread```函数。这里是初始化了线程的那部分。
- 初始化进程的虚拟地址池```create_user_vaddr_bitmap(thread);```
- 构建中断栈以及建立线程和函数的连接```thread_create```
  - <font color="red">注意，第二个参数```start_process```这个函数</font>
- 加入就绪队列中，等待被操作系统调度执行。
- 加入全部线程队列。



##### 2.2 ```init_thread```

这部分和实现内核线程一样。就是给PCB的静态属性赋值。

```c
/*
    Description:
        初始化线程的静态属性
    Parameters:
        pthread: struct task_struct*。要初始化的线程
        name: char*。该线程名字
        prio: int。该线程的优先级。
*/
void init_thread(struct task_struct *pthread, char *name, int prio)
{
    memset(pthread, 0, sizeof(*pthread));
    pthread->pid = allocate_pid();
    strcpy(pthread->name, name);

    if (pthread == main_thread)
    {
        /* 由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */
        pthread->status = TASK_RUNNING;
    }
    else
    {
        pthread->status = TASK_READY;
    }

    /* self_kstack在该线程的PCB顶部 */
    pthread->self_kstack = (uint32_t *)((uint32_t)pthread + PG_SIZE);
    pthread->priority = prio;
    pthread->ticks = prio;
    pthread->elapsed_ticks = 0;
    // 这里页表为空，因为线程没有页表
    pthread->pgdir = NULL;
    pthread->parent_pid = -1;          // -1表示没有父进程
    pthread->stack_magic = 0x19870916; // 自定义的魔数
}
```

- 就是填充PCB的字段
  - 比如申请pid
  - 给线程名称、线程状态、栈地址、优先级等属性赋值
- 设置了一个线程的栈地址，就是当前PCB的最顶端，如下图：
- <img src="https://gitee.com/imcgr/image_blog/raw/master/20210617164747.png" style="zoom: 80%; " align="left" />



##### 2.3 ```thread_create```

这部分依然和创建内核线程一样。

```c
/*
    Description:
        初始化pthread线程，需要执行的代码，以及上下文环境（寄存器、栈）。
    Parameters:
        pthread: struct task_struct*。要操作的线程
        function: 该线程要执行的代码地址
        func_arg: function对应的参数。function(func_arg)
    Details:
        - 预留中断栈空间
        - 预留线程栈空间
        - 设置线程栈的内容（在执行线程切换时，会操作该线程栈）
            - 执行的函数地址function放入栈中的function位置，该地址从栈中弹出可以执行
            - 栈中保存function函数需要的参数
            - 栈中其他寄存器的镜像，没用，都清0
*/
void thread_create(struct task_struct *pthread, thread_func function, void *func_arg)
{
    /* 先预留中断使用栈的空间,可见thread.h中定义的结构 */
    pthread->self_kstack -= sizeof(struct intr_stack);

    /* 再留出线程栈空间,可见thread.h中定义 */
    pthread->self_kstack -= sizeof(struct thread_stack);
    // 设置线程栈的内容，把要执行的函数地址function放入栈中的function位置
    struct thread_stack *kthread_stack = (struct thread_stack *)pthread->self_kstack;
    
    kthread_stack->eip = kernel_thread;
    
    kthread_stack->function = function;
    kthread_stack->func_arg = func_arg;
    // 栈中的寄存器镜像，都清0 
    kthread_stack->ebp = kthread_stack->ebx = kthread_stack->esi = kthread_stack->edi = 0;
}
```

- 这里会把```kernel_thread```函数作为线程栈中的eip的内容
  - 也就是被调度时，就会执行kernel_thread函数
- 在上一级的```process_execute```函数中，给这里的```thread_create```函数传进来第二个参数是```start_process```函数
  - 这里又把```start_proecss```函数作为了线程栈的```kernel_stack->function```字段。
  - 也就是间接把```start_process```函数作为参数，传给了```kernel_thread```函数。

##### 2.4 ```kernel_thread```

kernel_thread函数也没变，和创建内核线程时一样：

```c
/* 由kernel_thread去执行function(func_arg) */
static void kernel_thread(thread_func *function, void *func_arg)
{
    /* 执行function前要开中断,避免后面的时钟中断被屏蔽,而无法调度其它线程 */
    intr_enable();
    function(func_arg);
}
```

- 这里参数```function```就是上一级传进来的```start_process```函数。
- 所以会去执行```start_process```函数

##### 2.5 ```start_process```

这是和实现内核线程不一样的地方，这里多了一个```start_process```函数：

```c
/*
    Description:
        构建用户进程中断栈信息
    Parameters:
        filename: void* 用户进程欲执行的函数
    Details:
        - 构建好中断栈，然后执行intr_exit中断退出
        - 让CPU以为是从中断处理程序中退出
        - 因此实现CPU从0特权级到3特权级
*/
void start_process(void *filename_)
{
    void *function = filename_;
    struct task_struct *cur = running_thread();
    cur->self_kstack += sizeof(struct thread_stack);
    struct intr_stack *proc_stack = (struct intr_stack *)cur->self_kstack;
    proc_stack->edi = proc_stack->esi = proc_stack->ebp = proc_stack->esp_dummy = 0;
    proc_stack->ebx = proc_stack->edx = proc_stack->ecx = proc_stack->eax = 0;
    proc_stack->gs = 0; // 用户态用不上,直接初始为0
    proc_stack->ds = proc_stack->es = proc_stack->fs = SELECTOR_U_DATA;
    proc_stack->eip = function; // 待执行的用户程序地址
    proc_stack->cs = SELECTOR_U_CODE;
    proc_stack->eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);
    proc_stack->esp = (void *)((uint32_t)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE);
    proc_stack->ss = SELECTOR_U_DATA;
    asm volatile("movl %0, %%esp; jmp intr_exit"
                 :
                 : "g"(proc_stack)
                 : "memory");
}
```

- <font color="red">```函数start_process```是用户进程的精髓所在</font>

  - ```start_process```函数填充了中断栈的信息。
  - <font color="red">填充中断栈，然后让CPU以为自己处于中断处理程序中，然后弹出中断栈，然后去执行用户程序代码</font>。
  - 当执行```start_process```函数的最后一条指令（```asm volatile("xxx; jmp intr_exit");```）时，执行到```jmp intr_exit```里面的```iret```指令，会从中断退出。就会弹出0级栈的上下文。
  - 此时，会从中断栈中弹出eip位置的值，也就是自定义函数的地址，然后去执行该自定义函数。

##### 2.6 ```create_pagedir```

```c
/*
    Description:
        - 创建页目录表：申请1页物理内存，作为页目录表。
        - 把内核页目录表的[768, 1023]项复制到该页目录表的[768, 1023]项中
        - 该页目录表的1023项（最后1项）填充为自身页目录表的地址
    Returns:
        page_dir_vaddr: 申请到的物理页对应的虚拟地址
        NULL：如果申请失败返回NULL
*/
uint32_t *create_page_dir(void)
{

    // 1. 申请1页空间
    uint32_t *page_dir_vaddr = get_kernel_pages(1);
    if (page_dir_vaddr == NULL)
    {
        console_put_str("create_page_dir: get_kernel_page failed!");
        return NULL;
    }

    // 复制内核页表的768-1023项
    // page_dir_vaddr + 0x300 * 4 是页目录表第768项的地址（0x300 = 768）
    memcpy((uint32_t *)((uint32_t)page_dir_vaddr + 0x300 * 4), (uint32_t *)(0xfffff000 + 0x300 * 4), 1024);

    // 更新页表第1023项的地址
    uint32_t new_page_dir_phy_addr = addr_v2p((uint32_t)page_dir_vaddr);
    page_dir_vaddr[1023] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;
    return page_dir_vaddr;
}
```

- 创建页目录表，就是申请1页内存，然后把内核页目录表项的[768, 1023]项复制过去。

#### 3. 创建用户进程总结

代码调用过程

创建过程代码调用如下图所示：

图片太大，可能打不开，点击链接：<a href="https://gitee.com/imcgr/image_blog/raw/master/20210621183017.png">用户进程创建过程</a>

![用户进程创建过程](https://gitee.com/imcgr/image_blog/raw/master/20210621183017.png)



### 五、用户进程和内核进程的创建过程比较

跟之前的创建内核线程相比，步骤会多一些，多了关键的一步：填充中断栈，让CPU以为自己处于中断处理程序中，然后退出中断处理程序，弹出中断栈。

**内核线程**，只需创建线程栈，然后等调度器来调度，弹出线程栈即可运行自定义函数，比较容易，内核线程创建时函数调用如下：

![](https://gitee.com/imcgr/image_blog/raw/master/20210621193312.png)

而用户进程需要转换特权级，需要使用```iret```指令来从0级切换到3级。所以不光要构建线程栈，还要构建中断栈，然后“假装”从中断退出，进入3特权级，然后再执行3特权级的自定义函数。

**用户进程**创建函数调用如下：

![](https://gitee.com/imcgr/image_blog/raw/master/20210621190721.png)





主要区别如下：

- 用户进程给PCB填充了页表和虚拟地址池
- 内核线程```thread_start```把自定义函数```function```和参数```func_arg```作为```kernel_thread```的参数
  
  - 所以进入```kernel_thread```函数后，会直接执行自定义函数```function```
- 用户进程```process_execute``` 把```start_process```函数和自定义函数```filename```作为```kernel_thread```的参数
  - 所以进入```kernel_thread```函数后，会执行```start_process```函数，并且把自定义函数```filename```作为了```start_process```的参数
  - 在```start_process```中，把自定义函数```filename```作为中断栈的eip位置，所以从中断栈弹出时，会去执行自定义函数。

- 相当于用户程序多转了一层：

  - 内核线程执行时，等待调度器调度，就从线程栈弹出eip（```kernel_thread```的地址），就会去执行```kernel_thread```，然后就直接执行了自定义函数。
  - 用户进程执行时，等待调度器调度，从线程栈弹出eip（```kernel_thread```的地址），就会去执行```kernel_thread```，然后在```kernel_thread```会去执行了```start_process```函数，然后在```start_process```函数构建中断栈，然后再从中断退出，0特权级变为3特权级，然后执行自定义函数。
  - 关于内核线程执行和用户进程执行，对比如下：

  <img src="https://gitee.com/imcgr/image_blog/raw/master/20210621195959.png" style="zoom: 67%;" alt="内核线程和用户进程执行" />

  - 根据上图，用户进程需要使用```start_process```的根本原因就是因为，用户进程在3特权级。所以需要构建中断栈，假装中断退出，那么就会从0级转换到3级，然后再执行自定义函数。



### 六、总结

在已经实现了内核线程之后，再实现用户进程就比较简单了，构建内核线程和构建用户进程基本差不多，都是填充PCB就算完成了。然后把构建好的PCB加入就绪队列，等待被执行。

但是在<font color="red">构建PCB关键在于构建线程栈和中断栈</font>。



- 构建线程栈，该程序才有机会执行。
  - 构建好了线程栈，该线程被调度时，才可以假装弹线程栈，恢复上下文，借机执行该线程设定的函数。
    - 在内核线程中，恢复线程栈的上下文时是执行```kernel_thread```，然后进入```kernel_thread```里面，再执行自定义函数
    - 在用户进程中，同样是执行```kernel_thread```，但是进入```kernel_thread```里面，执行的是```start_process```。
- 构建中断栈，才有机会执行用户程序。
  - 构建好中断栈，使用```iret``指令让CPU以为要从中断退出，进而弹出中断栈，让CPU从0特权级到3特权级。
    - 在创建用户进程时，构建中断栈是在```start_process```中进行的，并把自定义函数，放在中断栈的eip位置。这样弹出中断时，就会去执行自定义函数。



创建一个用户程序，创建好的PCB如下图所示：

（图片太大？点击链接查看：<a href="https://gitee.com/imcgr/image_blog/raw/master/20210621202819.png">用户程序完整PCB结构</a>）

![用户程序完整PCB结构](https://gitee.com/imcgr/image_blog/raw/master/20210621202819.png)



