## 操作系统实战：中断的注册和触发

### 一、 介绍

<font color="red">本篇文章主要对中断部分代码的分析和总结，中断的理论部分，在其他地方。</font>

本节主要是实现，当中断触发时，根据**中断号**，去找到**中断描述符表**中的**中断描述符**，然后中断描述符中有**中断处理程序**目标代码段的**选择子**和**偏移量**，然后去执行该代码段也就是**中断处理函数**。

触发流程如下图：

![](https://i.loli.net/2021/06/11/6f9U1bDSRNiJ2k4.png)



**简单来讲**：所以我们要做的有一下几件事：

- **构建中断描述符表**，把中断描述符表地址给GDTR寄存器。这样发生中断时可以找到中断描述符表。
- **构建中断处理函数**，发生不同的中断执行不同的中断处理函数。
- **建立中断描述符和中断处理函数的连接**，这样发生中断时，根据中断描述符可以找到中断处理函数并执行。
  - 这里需要加一层中断处理函数入口表，因为在执行中断处理函数时，CPU特权级为0级，那么执行完中断，需要通过iret指令回到原来的特权级。
  - 所以**中断处理函数入口表 只能使用汇编写**。
- 如果是设置硬件中断，还要把中断号映射到中断控制器8259A的硬件接口中
  - 中断控制器接收所有来自外部硬件的中断，但是硬件中断不知道去执行什么中断处理函数
  - 所以要把硬件接口和中断号建立联系，然后触发硬件中断，可以根据相应的中断号，执行中断处理程序
  - 如何把硬件接口和中断号建立联系？只需操作中断控制器8259A的OCW控制字即可



实现代码的逻辑结构如下：

![](https://i.loli.net/2021/06/11/ObWdg8RwKGAakTm.png)

> 图中没有对中断控制器8259A的初始化进行分析，因为对中断控制器8259A的初始化比较固定，逻辑上比较容易理解，所以没有放在图上。但是对中断控制器8259A的初始化在下面有讲解。

### 二、重点讲解

首先代码为什么要这么写，是因为CPU有如下设定：

- 所谓中断，就是打断CPU去干另外一件事。

- CPU的运行机制就是执行一条指令，查看一次中断，如果有中断发生，就去执行跟该中断对应的中断处理程序。

所以操作系统所做的事情，就是构建好中断处理程序，当CPU收到中断信号（硬中断或软中断）时，就可以执行相应的中断处理程序。

#### 1. CPU是如何找到中断处理程序的？

当发生中断，CPU就会执行中断处理程序的，那么CPU是如何找到中断处理程序的？

CPU的执行中断是这样设计的：

- 把所有的中断处理程序都有一种数据结构来描述，叫做**中断门描述符**
  - 中断门描述符记录了中断处理程序代码段的选择子和偏移量等属性
- 很多中断处理程序就有很多中断门描述符，很多中断门描述符组成**中断描述符表IDT(Interrupt Descriptor Table)**
- 每一个中断都有一个中断号，这个中断号就是中断描述符表的下标，用来定位中断描述符
- 把中断描述符表的地址放在**IDTR(Interrupt Descriptor Table Register)寄存器**中



所以CPU找到中断处理程序是如下顺序的：

- 找到IDTR寄存器，得到中断描述符表的地址
- 根据发生时的**中断号**作为IDT中断描述符表的下标，定位中断描述符
- 中断描述符包含了目标代码段的**选择子**和**偏移量**
- 根据选择子和偏移量定位到具体的中断处理程序，并执行



#### 2. 处理中断时，会发生什么？

发生中断，去处理中断处理程序，有点像调用子程序的感觉（但不一样），执行完中断还要回到原来的地方的，所以肯定是要保存上下文的，这样执行完中断后，从栈中取出进入中断时压入栈的地址，然后回到中断前。

所以执行中断处理程序，根据特权级是否变化，可以分成两种情况：

- 特权级从3级到0级
  - 比如CPU在执行用户代码（特权级是3级），然后发生了中断
- 特权级没有变化从0级到0级
  - 比如CPU在执行内核代码，发生中断，这时特权级没有变化



特权级是否变化，保存上下文时，压栈情况也不一样，也需要分类讨论：

- 特权级从3级到0级的压栈情况：
  - 那么CPU就会进入0特权级，使用的也是0级栈（0级栈的地址从TSS中取得）
  - 那么会把原先的栈（3级栈）地址ss和esp压入0级栈保存（因为等会儿还要恢复的）
  - 把eflags寄存的值压栈（0级栈）保存
  - 把cs、eip的值保存（cs、eip是原先执行流的地址，必须保存，等会儿恢复，就可以回到原先的执行流）
  - 压入错误码error code（有的中断会压入，有的中断不会压入）
- 特权级从0级到0级的压栈情况：
  - CPU原先就是0级，所以执行中断处理程序，**不需要换栈**
  - 所以直接把elfags、ss、esp、error_code入栈即可



压栈情况如图所示：

![](https://i.loli.net/2021/06/11/5nLhr9Uk8GdbYB4.png)



> 注意：上述的压栈过程是CPU自动完成的，是在为执行中断处理程序做准备。



#### 3. 代码实现

#####　3.1 实现中断处理函数

不同的中断，要执行不同的中断处理函数。所以我们先构建一个中断处理函数数组：

```c
#define IDT_DESC_CNT 0x21 // 定义支持中断的个数
typedef intr_handler void*;　// intr_handler为void*，存放函数的地址
intr_handler idt_table[IDT_DESC_CNT]; // 中断处理函数数组，存放中断处理函数，每一个元素都是一个函数的地址
char *intr_name[IDT_DESC_CNT]; // 中断的名称
```

对中断处理函数数组初始化：

```c
/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void)
{ // 完成一般中断处理函数注册及异常名称注册
    for (int i = 0; i < IDT_DESC_CNT; i++)
    {
        /* 
            idt_table是中断处理程序表，存放的是中断处理程序（函数）地址，
            kernel/kernel.S的call [idt_table + %1*4]
        */
        /* 
            中断处理程序默认为general_intr_handler
            以后会由register_handler来注册具体处理函数。
        */
        idt_table[i] = general_intr_handler;
        /*
            中断名称先统一赋值为unknown
        */ 
        intr_name[i] = "unknown";
    }
    // 下面是所有可选的中断名称
    intr_name[0] = "#DE Divide Error";
    intr_name[1] = "#DB Debug Exception";
    intr_name[2] = "NMI Interrupt";
    intr_name[3] = "#BP Breakpoint Exception";
    intr_name[4] = "#OF Overflow Exception";
    intr_name[5] = "#BR BOUND Range Exceeded Exception";
    intr_name[6] = "#UD Invalid Opcode Exception";
    intr_name[7] = "#NM Device Not Available Exception";
    intr_name[8] = "#DF Double Fault Exception";
    intr_name[9] = "Coprocessor Segment Overrun";
    intr_name[10] = "#TS Invalid TSS Exception";
    intr_name[11] = "#NP Segment Not Present";
    intr_name[12] = "#SS Stack Fault Exception";
    intr_name[13] = "#GP General Protection Exception";
    intr_name[14] = "#PF Page-Fault Exception";
    // intr_name[15] 第15项是intel保留项，未使用
    intr_name[16] = "#MF x87 FPU Floating-Point Error";
    intr_name[17] = "#AC Alignment Check Exception";
    intr_name[18] = "#MC Machine-Check Exception";
    intr_name[19] = "#XF SIMD Floating-Point Exception";
}

/* 先设置一个通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr)
{
    if (vec_nr == 0x27 || vec_nr == 0x2f)
    {           // 0x2f是从片8259A上的最后一个irq引脚，保留
        return; //IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
    }
    put_str("int vector: 0x");
    put_int(vec_nr);
    put_char('\n');
}
```

上述就是中断处理函数数组，数组元素保存了具体的中断处理函数地址。

##### 3.2 中断处理程序入口数组

有一点要注意，执行中断处理程序，跟执行子程序可不一样，因为这设计到**特权级变化**，所以<font color="red">**要能保证，比如原来是3级，执行中断处理程序变为0级，执行完毕后，要回到3级**</font>。

所以**中断处理程序要使用iret指令来返回**，才可以退出中断处理程序。这是跟普通的子程序是不一样的。

所以，这里对上面的中断处理函数再次做了一层封装，让**汇编代码，调用上述的中断处理函数```idt_table[i]```，然后再使用iret指令退出中断处理程序**。

所以这里构建了中断处理程序入口数组：

```assembly
; kernel.S
[bits 32]
%define ERROR_CODE nop		 ; 若在相关的异常中cpu已经自动压入了错误码,为保持栈中格式统一,这里不做操作.
%define ZERO push 0		 ; 若在相关的异常中cpu没有压入错误码,为了统一栈中格式,就手工压入一个0

extern idt_table		 ;idt_table是C中注册的中断处理程序数组

section .data
global intr_entry_table
intr_entry_table:

%macro VECTOR 2
section .text
intr%1entry:		 ; 每个中断处理程序都要压入中断向量号,所以一个中断类型一个中断处理程序，自己知道自己的中断向量号是多少

   %2				 ; 中断若有错误码会压在eip后面 
; 以下是保存上下文环境
   push ds
   push es
   push fs
   push gs
   pushad			 ; PUSHAD指令压入32位寄存器,其入栈顺序是: EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI

   ; 如果是从片上进入的中断,除了往从片上发送EOI外,还要往主片上发送EOI 
   mov al,0x20                   ; 中断结束命令EOI
   out 0xa0,al                   ; 向从片发送
   out 0x20,al                   ; 向主片发送

   push %1			 ; 不管idt_table中的目标程序是否需要参数,都一律压入中断向量号,调试时很方便
   call [idt_table + %1*4]       ; 调用idt_table中的C版本中断处理函数
   jmp intr_exit

section .data
   dd    intr%1entry	 ; 存储各个中断入口程序的地址，形成intr_entry_table数组
%endmacro

section .text
global intr_exit
intr_exit:	     
; 以下是恢复上下文环境
   add esp, 4			   ; 跳过中断号
   popad
   pop gs
   pop fs
   pop es
   pop ds
   add esp, 4			   ; 跳过error_code
   iretd

VECTOR 0x00,ZERO
VECTOR 0x01,ZERO
VECTOR 0x02,ZERO
VECTOR 0x03,ZERO 
VECTOR 0x04,ZERO
VECTOR 0x05,ZERO
VECTOR 0x06,ZERO
VECTOR 0x07,ZERO 
VECTOR 0x08,ERROR_CODE
VECTOR 0x09,ZERO
VECTOR 0x0a,ERROR_CODE
VECTOR 0x0b,ERROR_CODE 
VECTOR 0x0c,ZERO
VECTOR 0x0d,ERROR_CODE
VECTOR 0x0e,ERROR_CODE
VECTOR 0x0f,ZERO 
VECTOR 0x10,ZERO
VECTOR 0x11,ERROR_CODE
VECTOR 0x12,ZERO
VECTOR 0x13,ZERO 
VECTOR 0x14,ZERO
VECTOR 0x15,ZERO
VECTOR 0x16,ZERO
VECTOR 0x17,ZERO 
VECTOR 0x18,ERROR_CODE
VECTOR 0x19,ZERO
VECTOR 0x1a,ERROR_CODE
VECTOR 0x1b,ERROR_CODE 
VECTOR 0x1c,ZERO
VECTOR 0x1d,ERROR_CODE
VECTOR 0x1e,ERROR_CODE
VECTOR 0x1f,ZERO 
VECTOR 0x20,ZERO
```

> 所以上述汇编代码，主要是中断处理函数入口程序，调用中断处理函数，然后使用iret指令退出。

##### 3.3 中断描述符表

下面要来构建中断描述符了，因为CPU只认识中断描述符，是根据中断描述符来找到中断处理程序入口表的。



###### 3.1 构建中断描述符

中断描述符的结构：

![image-20210611153725340](https://i.loli.net/2021/06/11/Af96M5RTqg1ExyI.png)

如上图的中断描述符结构，有几个无关紧要的字段：

- TYPE
  - 表示多少位，对于中断门描述符来说，只有TYPE的D位是可变了
    - D为1表示32位
    - D位0表示16位
    - 这里是32位的操作系统，所以使用D为1
    - 也就是TYPE = 1110 = 0xE
- S
  - 默认为0
- DPL
  - 表示中断门描述符的特权级，只有符合该特权级的任务才可以调用它
  - 这里DPL = 0, 表示0级，也就是只有操作系统可以调用该中断门描述符
- P
  - P表示present是否存在，这里P为1

由此，我们构建出了我们需要的中断描述符的固定属性，待会儿会使用到：

```c
#define	 IDT_DESC_P	 1 
#define	 IDT_DESC_DPL0   0
#define	 IDT_DESC_DPL3   3
#define	 IDT_DESC_32_TYPE     0xE   // 32位的门
#define	 IDT_DESC_16_TYPE     0x6   // 16位的门，不用，定义它只为和32位门区分
#define	 IDT_DESC_ATTR_DPL0  ((IDT_DESC_P << 7) + (IDT_DESC_DPL0 << 5) + IDT_DESC_32_TYPE)
#define	 IDT_DESC_ATTR_DPL3  ((IDT_DESC_P << 7) + (IDT_DESC_DPL3 << 5) + IDT_DESC_32_TYPE)
```



构建出一个中断描述符结构体（结构要和上图中一模一样）：

```c
/*中断门描述符结构体*/
struct gate_desc
{
    /* 中断处理程序在目标代码段的偏移量的低16位 */
    uint16_t func_offset_low_word;
    /* 中断处理程序目标代码段的选择子 */
    uint16_t selector;
    /* 高32位的低8位（0-7），中断门描述符这几位都是0 */
    uint8_t dcount;
    /* 高32位的第8-15位，主要有TYPE(4 bits)、S(1 bit)、DPL(2 bits)、P(1 bit)*/
    uint8_t attribute;
    /* 中断处理程序在目标代码段的偏移量的高16位 */
    uint16_t func_offset_high_word;
};
```

下面要做的就是构建出一个有多个```struct gate_desc```结构的数组出来，表示中断描述符表。

下面这个函数，就是给```struct gate_desc```结构体赋值，**关键在于让中断描述符保存中断处理入口程序的地址**。

```c
/* 创建中断门描述符 */
static void make_idt_desc(struct gate_desc *p_gdesc, uint8_t attr, intr_handler function)
{
    /* function是中断处理函数，把function地址的低16位取出来 */
    p_gdesc->func_offset_low_word = (uint32_t)function & 0x0000FFFF;
    /* 目标代码段的选择子 */
    p_gdesc->selector = SELECTOR_K_CODE;
    p_gdesc->dcount = 0;
    p_gdesc->attribute = attr;
    /* 把function地址的高16位取出来 */
    p_gdesc->func_offset_high_word = ((uint32_t)function & 0xFFFF0000) >> 16;
}
```

###### 3.2 构建中断描述符表

把多个中断描述符组成一个数组，构成中断描述符表：

```c
static struct gate_desc idt[IDT_DESC_CNT];
```

然后把中断描述符填充到中断描述符表中：

```c
/*初始化中断描述符表*/
static void idt_desc_init(void)
{
    for (int i = 0; i < IDT_DESC_CNT; i++)
    {
        make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]);
    }
    put_str("idt_desc_init done\n");
}
```

这样一操作，中断就初始化好了，如果发生中断，CPU就可以执行相应的中断处理程序了（这里所有的中断处理程序都默认是```general_intr_handler```）。

<font color="red">具体的函数调用过程，可以看上面《一、基本介绍》中的图片所示</font>。

##### 3.4. 初始化中断控制器8259A

中断控制器8259A是用来接收**硬件中断**的，也需要操作系统进行配置，让控制器的硬件**接口**发生的映射到**中断号**中，这样来自硬件接口的中断，可以根据该接口对应的中断号去执行中断处理程序。

操作中断控制器259A主要就是往控制器特定的端口，写入数据即可。

<font color="red"><b>具体对中断控制器8259A的控制，可以看理论部分：《中断》</b></font>



但是其实对中断控制器的操作，比较固定，直接放代码：

```c
/* 初始化可编程中断控制器8259A */
static void pic_init(void) {

   /* 初始化主片 */
   outb (PIC_M_CTRL, 0x11);   // ICW1: 边沿触发,级联8259, 需要ICW4.
   outb (PIC_M_DATA, 0x20);   // ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.
   outb (PIC_M_DATA, 0x04);   // ICW3: IR2接从片. 
   outb (PIC_M_DATA, 0x01);   // ICW4: 8086模式, 正常EOI

   /* 初始化从片 */
   outb (PIC_S_CTRL, 0x11);    // ICW1: 边沿触发,级联8259, 需要ICW4.
   outb (PIC_S_DATA, 0x28);    // ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.
   outb (PIC_S_DATA, 0x02);    // ICW3: 设置从片连接到主片的IR2引脚
   outb (PIC_S_DATA, 0x01);    // ICW4: 8086模式, 正常EOI

   /* 打开主片上IR0,也就是目前只接受时钟产生的中断 */
   outb (PIC_M_DATA, 0xfe);    // 设置主片OCW，把主片除了0号接口的中断（时钟中断）都屏蔽掉
   outb (PIC_S_DATA, 0xff);    // 设置从片OCW，从片的所有OCW全部屏蔽

   put_str("   pic_init done\n");
}
```

在我看来，对中断控制器8295A的初始化主要在以下两点：

- <font color="red">映射硬件接口号到中断号</font>
  - 通过给ICW2写入控制字，可以将中断向量号[0x20-0x27]映射到接口IR[0-7]中
  - 这样来自不同的接口的中断，可以根据中断号去找到中断描述符表IDT，然后执行中断处理程序
- <font color="red">屏蔽特定的中断</font>
  - 通过操作OCW，可以选择屏蔽某些中断，本例子中把除了非时钟中断，都给屏蔽了。

### 三、完整代码实现

下面是```intrrupt.c```，包含了中断描述符的注册

```c
// interrupt.c
#include "interrupt.h"
#include "stdint.h"
#include "global.h"
#include "io.h"
#include "print.h"

#define PIC_M_CTRL 0x20 // 这里用的可编程中断控制器是8259A,主片的控制端口是0x20
#define PIC_M_DATA 0x21 // 主片的数据端口是0x21
#define PIC_S_CTRL 0xa0 // 从片的控制端口是0xa0
#define PIC_S_DATA 0xa1 // 从片的数据端口是0xa1

#define IDT_DESC_CNT 0x21 // 目前总共支持的中断数

#define EFLAGS_IF 0x00000200 // eflags寄存器中的if位为1
#define GET_EFLAGS(EFLAG_VAR) asm volatile("pushfl; popl %0" \
                                           : "=g"(EFLAG_VAR))

/*中断门描述符结构体*/
struct gate_desc
{
    /* 中断处理程序在目标代码段的偏移量的低16位 */
    uint16_t func_offset_low_word;
    /* 中断处理程序目标代码段的选择子 */
    uint16_t selector;
    /* 高32位的低8位（0-7），中断门描述符这几位都是0 */
    uint8_t dcount;
    /* 高32位的第8-15位，主要有TYPE(4 bits)、S(1 bit)、DPL(2 bits)、P(1 bit)*/
    uint8_t attribute;
    /* 中断处理程序在目标代码段的偏移量的高16位 */
    uint16_t func_offset_high_word;
};

// 静态函数声明,非必须
static void make_idt_desc(struct gate_desc *p_gdesc, uint8_t attr, intr_handler function);
static struct gate_desc idt[IDT_DESC_CNT]; // idt是中断描述符表,本质上就是个中断门描述符数组

char *intr_name[IDT_DESC_CNT];                      // 用于保存异常的名字
intr_handler idt_table[IDT_DESC_CNT];               // 定义中断处理程序数组.在kernel.S中定义的intrXXentry只是中断处理程序的入口,最终调用的是ide_table中的处理程序
extern intr_handler intr_entry_table[IDT_DESC_CNT]; // 声明引用定义在kernel.S中的中断处理函数入口数组

/* 初始化可编程中断控制器8259A */
static void pic_init(void)
{

    /* 初始化主片 */
    outb(PIC_M_CTRL, 0x11); // ICW1: 边沿触发,级联8259, 需要ICW4.
    outb(PIC_M_DATA, 0x20); // ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.
    outb(PIC_M_DATA, 0x04); // ICW3: IR2接从片.
    outb(PIC_M_DATA, 0x01); // ICW4: 8086模式, 正常EOI

    /* 初始化从片 */
    outb(PIC_S_CTRL, 0x11); // ICW1: 边沿触发,级联8259, 需要ICW4.
    outb(PIC_S_DATA, 0x28); // ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.
    outb(PIC_S_DATA, 0x02); // ICW3: 设置从片连接到主片的IR2引脚
    outb(PIC_S_DATA, 0x01); // ICW4: 8086模式, 正常EOI

    /* 打开主片上IR0,也就是目前只接受时钟产生的中断 */
    outb(PIC_M_DATA, 0xfe);
    outb(PIC_S_DATA, 0xff);

    put_str("   pic_init done\n");
}

/* 创建中断门描述符 */
static void make_idt_desc(struct gate_desc *p_gdesc, uint8_t attr, intr_handler function)
{
    /* function是中断处理函数，把function地址的低16位取出来 */
    p_gdesc->func_offset_low_word = (uint32_t)function & 0x0000FFFF;
    /* 目标代码段的选择子 */
    p_gdesc->selector = SELECTOR_K_CODE;
    p_gdesc->dcount = 0;
    p_gdesc->attribute = attr;
    /* 把function地址的高16位取出来 */
    p_gdesc->func_offset_high_word = ((uint32_t)function & 0xFFFF0000) >> 16;
}

/*初始化中断描述符表*/
static void idt_desc_init(void)
{
    for (int i = 0; i < IDT_DESC_CNT; i++)
    {
        make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]);
    }
    put_str("idt_desc_init done\n");
}

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr)
{
    if (vec_nr == 0x27 || vec_nr == 0x2f)
    {           // 0x2f是从片8259A上的最后一个irq引脚，保留
        return; //IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
    }
    put_str("int vector: 0x");
    put_int(vec_nr);
    put_char('\n');
}

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void)
{ // 完成一般中断处理函数注册及异常名称注册
    int i;
    for (i = 0; i < IDT_DESC_CNT; i++)
    {

        /* 
            idt_table是中断处理程序表，存放的是中断处理程序（函数）地址，
            kernel/kernel.S的call [idt_table + %1*4]
        */
        /* 
            中断处理程序默认为general_intr_handler
            以后会由register_handler来注册具体处理函数。
        */
        idt_table[i] = general_intr_handler;
        /*
            中断名称先统一赋值为unknown
        */
        intr_name[i] = "unknown";
    }
    // 下面是所有可选的中断名称
    intr_name[0] = "#DE Divide Error";
    intr_name[1] = "#DB Debug Exception";
    intr_name[2] = "NMI Interrupt";
    intr_name[3] = "#BP Breakpoint Exception";
    intr_name[4] = "#OF Overflow Exception";
    intr_name[5] = "#BR BOUND Range Exceeded Exception";
    intr_name[6] = "#UD Invalid Opcode Exception";
    intr_name[7] = "#NM Device Not Available Exception";
    intr_name[8] = "#DF Double Fault Exception";
    intr_name[9] = "Coprocessor Segment Overrun";
    intr_name[10] = "#TS Invalid TSS Exception";
    intr_name[11] = "#NP Segment Not Present";
    intr_name[12] = "#SS Stack Fault Exception";
    intr_name[13] = "#GP General Protection Exception";
    intr_name[14] = "#PF Page-Fault Exception";
    // intr_name[15] 第15项是intel保留项，未使用
    intr_name[16] = "#MF x87 FPU Floating-Point Error";
    intr_name[17] = "#AC Alignment Check Exception";
    intr_name[18] = "#MC Machine-Check Exception";
    intr_name[19] = "#XF SIMD Floating-Point Exception";
}

/* 开中断并返回开中断前的状态*/
enum intr_status intr_enable()
{
    enum intr_status old_status;
    if (INTR_ON == intr_get_status())
    {
        old_status = INTR_ON;
        return old_status;
    }
    else
    {
        old_status = INTR_OFF;
        asm volatile("sti"); // 开中断,sti指令将IF位置1
        return old_status;
    }
}

/* 关中断,并且返回关中断前的状态 */
enum intr_status intr_disable()
{
    enum intr_status old_status;
    if (INTR_ON == intr_get_status())
    {
        old_status = INTR_ON;
        asm volatile("cli"
                     :
                     :
                     : "memory"); // 关中断,cli指令将IF位置0
        return old_status;
    }
    else
    {
        old_status = INTR_OFF;
        return old_status;
    }
}

/* 将中断状态设置为status */
enum intr_status intr_set_status(enum intr_status status)
{
    return status & INTR_ON ? intr_enable() : intr_disable();
}

/* 获取当前中断状态 */
enum intr_status intr_get_status()
{
    uint32_t eflags = 0;
    GET_EFLAGS(eflags);
    return (EFLAGS_IF & eflags) ? INTR_ON : INTR_OFF;
}

/*完成有关中断的所有初始化工作*/
void idt_init()
{
    put_str("idt_init start\n");
    idt_desc_init();  // 初始化中断描述符表
    exception_init(); // 异常名初始化并注册通常的中断处理函数
    pic_init();       // 初始化8259A

    /* 加载idt */
    uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt << 16));
    asm volatile("lidt %0"
                 :
                 : "m"(idt_operand));
    put_str("idt_init done\n");
}
```

```assembly
; kernel.S
[bits 32]
%define ERROR_CODE nop		 ; 若在相关的异常中cpu已经自动压入了错误码,为保持栈中格式统一,这里不做操作.
%define ZERO push 0		 ; 若在相关的异常中cpu没有压入错误码,为了统一栈中格式,就手工压入一个0

extern idt_table		 ;idt_table是C中注册的中断处理程序数组

section .data
global intr_entry_table
intr_entry_table:

%macro VECTOR 2
section .text
intr%1entry:		 ; 每个中断处理程序都要压入中断向量号,所以一个中断类型一个中断处理程序，自己知道自己的中断向量号是多少

   %2				 ; 中断若有错误码会压在eip后面 
; 以下是保存上下文环境
   push ds
   push es
   push fs
   push gs
   pushad			 ; PUSHAD指令压入32位寄存器,其入栈顺序是: EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI

   ; 如果是从片上进入的中断,除了往从片上发送EOI外,还要往主片上发送EOI 
   mov al,0x20                   ; 中断结束命令EOI
   out 0xa0,al                   ; 向从片发送
   out 0x20,al                   ; 向主片发送

   push %1			 ; 不管idt_table中的目标程序是否需要参数,都一律压入中断向量号,调试时很方便
   call [idt_table + %1*4]       ; 调用idt_table中的C版本中断处理函数
   jmp intr_exit

section .data
   dd    intr%1entry	 ; 存储各个中断入口程序的地址，形成intr_entry_table数组
%endmacro

section .text
global intr_exit
intr_exit:	     
; 以下是恢复上下文环境
   add esp, 4			   ; 跳过中断号
   popad
   pop gs
   pop fs
   pop es
   pop ds
   add esp, 4			   ; 跳过error_code
   iretd

VECTOR 0x00,ZERO
VECTOR 0x01,ZERO
VECTOR 0x02,ZERO
VECTOR 0x03,ZERO 
VECTOR 0x04,ZERO
VECTOR 0x05,ZERO
VECTOR 0x06,ZERO
VECTOR 0x07,ZERO 
VECTOR 0x08,ERROR_CODE
VECTOR 0x09,ZERO
VECTOR 0x0a,ERROR_CODE
VECTOR 0x0b,ERROR_CODE 
VECTOR 0x0c,ZERO
VECTOR 0x0d,ERROR_CODE
VECTOR 0x0e,ERROR_CODE
VECTOR 0x0f,ZERO 
VECTOR 0x10,ZERO
VECTOR 0x11,ERROR_CODE
VECTOR 0x12,ZERO
VECTOR 0x13,ZERO 
VECTOR 0x14,ZERO
VECTOR 0x15,ZERO
VECTOR 0x16,ZERO
VECTOR 0x17,ZERO 
VECTOR 0x18,ERROR_CODE
VECTOR 0x19,ZERO
VECTOR 0x1a,ERROR_CODE
VECTOR 0x1b,ERROR_CODE 
VECTOR 0x1c,ZERO
VECTOR 0x1d,ERROR_CODE
VECTOR 0x1e,ERROR_CODE
VECTOR 0x1f,ZERO 
VECTOR 0x20,ZERO
```

如果要中断可以被处理，需要执行```idt_init()```来初始化中断，也就是构建中断描述符表、中断处理程序等过程。

<font color="red">具体的函数调用过程，可以看上面《一、介绍》中的图片所示</font>。





